{"version":3,"sources":["dragular.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","dragular","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"dragularService","restrict","link","$scope","iElm","iAttrs","tryJson","json","JSON","parse","drake","options","$eval","containersModel","dynamicModelAttribute","$watch","dragularModel","newVal","sanitizeContainersModel","dragularNameSpace","nameSpace","split","$inject",2,"dragularDirective","angular","factory","directive","./dragularDirective","./dragularService",3,"shared","classesCache","containersCtx","containers","mirror","source","item","copy","sourceItem","sourceModel","sourceFilteredModel","target","targetCtx","targetModel","lastDropTarget","offsetX","offsetY","moveX","moveY","offsetXr","offsetYb","clientX","clientY","mirrorWidth","mirrorHeight","initialSibling","currentSibling","initialIndex","currentIndex","tempModel","dragOverEvents","lastElementBehindCursor","grabbed","$rootScope","service","arg0","arg1","Array","isArray","processServiceArguments","arguments","isElement","initialContainers","document","querySelectorAll","copyOptions","extendOptions","tmp","extend","defaultOptions","classes","defaultClasses","eventNames","defaultEventNames","processOptionsObject","boundingBox","makeArray","containersFilteredModel","forEach","len","shLen","m","getContainersModel","fm","registerEvents","remove","op","regEvent","docElm","release","container","grab","name","eventName","doc","createEvent","initEvent","createEventObject","eventType","whichMouseButton","metaKey","ctrlKey","context","canStart","eventualMovements","type","isInput","focus","preventDefault","ungrab","dragging","getCoord","elementBehindCursor","getElementBehindPoint","dropTarget","findDropTarget","copySortSource","drop","removeOnSpill","cancel","fireEvent","dragularrelease","scope","$emit","isContainer","el","indexOf","isContainerModel","removeContainers","all","$applyAsync","changes","index","splice","startBecauseMouseMoved","movements","preventGrabbed","destroy","ignoreInputTextSelection","elementFromPoint","end","start","direction","getParent","parent","parentNode","parentHeight","offsetHeight","parentWidth","offsetWidth","childHeight","clientHeight","childWidth","clientWidth","offset","getOffset","left","top","right","bottom","addClass","transit","renderMirrorImage","style","drag","handle","invalid","moves","nextEl","manualStart","cloneNode","dragularcloned","containerIndex","domIndexOf","dragulardrag","emitDropEvent","isInitialPlacement","dragularcancel","dragulardrop","dropIndex","removeChild","dropElmModel","dontCopyModel","cleanup","dragularremove","revert","reverts","revertOnSpill","initial","insertBefore","removeMirrorImage","rmClass","spillOut","dragularout","dragulardragend","sibling","accepted","accepts","immediate","getImmediateChild","reference","getReference","dragularCommon","canBeAccepted","moved","spillOver","pageX","pageY","offsetBox","x","y","lockY","lockX","changed","dragularenter","dragularleave","dragularshadow","hide","scrollContainer","before","scrollTop","deltaY","stopPropagation","rect","getBoundingClientRect","width","height","getRectWidth","getRectHeight","mirrorContainer","appendChild","body","unselectable","outside","children","horizontal","inside","resolve","after","point","p","state","className","getBool","dragularover","never","getEmptyObject","always","fn","touch","mouseup","mousedown","mousemove","pointers","microsoft","$el","element","navigator","pointerEnabled","msPointerEnabled","startIndex","prototype","slice","touches","undefined","buttons","which","button","getScroll","scrollProp","offsetProp","scrollLeft","manually","nextSibling","nodeType","nextElementSibling","obj","HTMLElement","nodeName","lookupClass","cached","lastIndex","RegExp","current","test","replace","trim","getEventHost","targetTouches","changedTouches","coord","host","missMap","originalEvent","tagName","isEditable","contentEditable","child","extra","dispatchEvent","prop","args","isFunction","apply","documentElement","cleanEnviroment"],"mappings":"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","file":"dragular.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.dragular = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\n/**\n * dragular Directive by Luckylooke https://github.com/luckylooke/dragular\n * Angular version of dragula https://github.com/bevacqua/dragula\n */\n\nvar dragular = function (dragularService) {\n  return {\n    restrict: 'A',\n    link: function($scope, iElm, iAttrs) {\n\n      var drake,\n        options = $scope.$eval(iAttrs.dragular) || tryJson(iAttrs.dragular) || {};\n\n      function tryJson(json) {\n        try { // I dont like try catch solutions but I havent find sattisfying way of chcecking json validity.\n          return JSON.parse(json);\n        } catch (e) {\n          return undefined;\n        }\n      }\n\n      if(options && options.containersModel && typeof options.containersModel === 'string'){\n        options.containersModel = $scope.$eval(options.containersModel);\n      }\n\n      if(options && options.dynamicModelAttribute){\n        // watch for model changes\n        $scope.$watch(function () {\n          return $scope.$eval(iAttrs.dragularModel);\n        }, function (newVal) {\n          if(newVal){\n            drake.containersModel = drake.sanitizeContainersModel($scope.$eval(newVal));\n          }\n        });\n      }else if(iAttrs.dragularModel){\n        // bind once and keep reference\n        options.containersModel = $scope.$eval(iAttrs.dragularModel);\n      }\n\n      if(iAttrs.dragularNameSpace){\n        options.nameSpace = iAttrs.dragularNameSpace.split(' ');\n      }\n\n      drake = dragularService(iElm[0], options);\n    }\n  };\n};\n\ndragular.$inject = ['dragularService'];\n\nmodule.exports = dragular;\n\n},{}],2:[function(require,module,exports){\n/* global angular */\n'use strict';\nvar dragularDirective = require('./dragularDirective');\nvar dragularService = require('./dragularService');\n\n/**\n * Dragular 4.0.0 by Luckylooke https://github.com/luckylooke/dragular\n * Angular version of dragula https://github.com/bevacqua/dragula\n */\nmodule.exports = 'dragularModule';\n\nangular\n  .module('dragularModule', [])\n  .factory('dragularService', dragularService)\n  .directive('dragular', dragularDirective);\n\n},{\"./dragularDirective\":1,\"./dragularService\":3}],3:[function(require,module,exports){\n(function (global){\n/* global angular */\n'use strict';\n\n/**\n * dragular Service by Luckylooke https://github.com/luckylooke/dragular\n * Angular version of dragula https://github.com/bevacqua/dragula\n */\n\nvar shared = { // sahred object between all service instances\n  classesCache: {}, // classes lookup cache\n  containersCtx: {}, // containers model\n  containers: {}, // containers\n  mirror: null, // mirror image\n  source: null, // source container\n  item: null, // item being dragged\n  copy: null, // copy flag\n  sourceItem: null, // item originaly dragged if copy is enabled\n  sourceModel: null, // source container model\n  sourceFilteredModel: null, // source container filtered model if relevant\n  target: null, // droppable container under drag item\n  targetCtx: null, // target container context\n  targetModel: null, // target container model\n  lastDropTarget: null, // last container item was over\n  offsetX: null, // reference x\n  offsetY: null, // reference y\n  moveX: null, // reference move x\n  moveY: null, // reference move y\n  offsetXr: null, // reference x right for boundingBox feature\n  offsetYb: null, // reference y bottom for boundingBox feature\n  clientX: null, // cache client x, init at grab, update at drag\n  clientY: null, // cache client y, init at grab, update at drag\n  mirrorWidth: null, // mirror width for boundingBox feature\n  mirrorHeight: null, // mirror height for boundingBox feature\n  initialSibling: null, // reference sibling when grabbed\n  currentSibling: null, // reference sibling now\n  initialIndex: null, // reference model index when grabbed\n  currentIndex: null, // reference model index now\n  tempModel: null, // if o.isContainer is used, model can be provided as well, it is temporary saved here during drags\n  dragOverEvents: {}, // drag over events fired on element behind cursor\n  lastElementBehindCursor: null, // last element behind cursor\n  grabbed: null // holds mousedown context until first mousemove\n};\n\nvar dragularService = function ($rootScope) {\n  // abbreviations\n  var doc = document,\n      docElm = doc.documentElement;\n\n  // clean common/shared objects\n  service.cleanEnviroment = function cleanEnviroment() {\n    shared.classesCache = {};\n    shared.containersCtx = {};\n    shared.containers = {};\n    shared.mirror = undefined;\n  };\n\n  service.shared = shared;\n\n  return service;\n\n  // service definition\n  function service(arg0, arg1) {\n    var initialContainers = arg0 || [],\n      options = arg1 || {},\n      o, // shorthand for options\n      g = getBool, // shorthand for getBool\n      // defaults\n      defaultClasses = {\n        mirror: 'gu-mirror',\n        hide: 'gu-hide',\n        unselectable: 'gu-unselectable',\n        transit: 'gu-transit'\n      },\n      defaultEventNames = {\n        // drag-over DOM events\n        dragularenter: 'dragularenter',\n        dragularleave: 'dragularleave',\n        dragularrelease: 'dragularrelease',\n        // $scope events\n        dragularcloned: 'dragularcloned',\n        dragulardrag: 'dragulardrag',\n        dragularcancel: 'dragularcancel',\n        dragulardrop: 'dragulardrop',\n        dragularremove: 'dragularremove',\n        dragulardragend: 'dragulardragend',\n        dragularshadow: 'dragularshadow',\n        dragularover: 'dragularover',\n        dragularout: 'dragularout'\n      },\n      defaultOptions = { // options with defaults\n        copyOptions: false, // copy options object when provided\n        classes: defaultClasses, // classes used by dragular\n        eventNames: defaultEventNames, // event names used by dragular\n        containers: false, // initial containers provided via options object (are provided via parameter by default)\n        containersModel: false, // if provided, model will be synced with DOM\n        containersFilteredModel: false, // if provided, dragular will handle filtered model cases\n        isContainer: never, // potential target can be forced to be container by custom logic\n        isContainerModel: getEmptyObject, // if isContainer function is provided, you can provide also respective model\n        moves: always, // can drag start?\n        accepts: always, // can target accept dragged item? (target context used)\n        canBeAccepted: always, // can be dragged item accepted by target? (source context used)\n        copy: false, // dragged item will be copy of source? flag or function\n        copySortSource: false, // enable sorting in source when copying item\n        dontCopyModel: false, // dont make copy of model when coping item (#61)\n        invalid: never, // target (in)validity function\n        revertOnSpill: false, // item returns to original place\n        removeOnSpill: false, // item will be removed if not placed into valid target\n        lockX: false, // lock movement into x-axis\n        lockY: false, // lock movement into y-axis\n        boundingBox: false, // lock movement inside this element boundaries\n        mirrorContainer: doc.body, // element for appending mirror\n        ignoreInputTextSelection: true // text selection in inputs wont be considered as drag\n      },\n      drake = {\n        containers: shared.containers,\n        containersCtx: shared.containersCtx,\n        sanitizeContainersModel: sanitizeContainersModel,\n        isContainer: isContainer,\n        start: manualStart,\n        end: end,\n        cancel: cancel,\n        remove: remove,\n        destroy: destroy,\n        dragging: false\n      };\n\n    processServiceArguments(); // both arguments (containers and options) are optional, this function handle this\n    extendOptions();\n    processOptionsObject();\n    registerEvents();\n\n    return drake;\n\n    // Function definitions: ==============================================================================================================\n    // Initial functions: -----------------------------------------------------------------------------------------------------------------\n\n    function sanitizeContainersModel(containersModel) {\n      if (typeof(containersModel) === 'function') {\n        return containersModel;\n      }\n      if (Array.isArray(containersModel)) {\n        //                  |-------- is 2D array? -----------|\n        return Array.isArray(containersModel[0]) ? containersModel : [containersModel];\n      } else {\n        return [];\n      }\n    }\n\n    function processServiceArguments(){\n      if (arguments.length === 1 && // if there is only one argument we need to distinguish if it is options object or container(s) reference\n          !Array.isArray(arg0) && // array of containers elements\n          !angular.isElement(arg0) && // one container element\n          !arg0[0] && // array-like object with containers elements\n          typeof arg0 !== 'string') { // selector\n        // then arg0 is options object\n        options = arg0 || {};\n        initialContainers = []; // containers are not provided on init\n      } else if (typeof arg0 === 'string') {\n        initialContainers = document.querySelectorAll(arg0);\n      }\n      o = options.copyOptions ? angular.copy(options) : options;\n    }\n\n    function extendOptions(){\n      var tmp = angular.extend({}, defaultOptions, o); // tmp for keeping defaults untouched\n      angular.extend(o, tmp); // merge defaults back into options\n      if(o.classes){\n        tmp = angular.extend({}, defaultClasses, o.classes);\n        angular.extend(o.classes, tmp);\n      }\n      if(o.eventNames){\n        tmp = angular.extend({}, defaultEventNames, o.eventNames);\n        angular.extend(o.eventNames, tmp);\n      }\n    }\n\n    function processOptionsObject(){\n      // bounding box must be pure DOM element, not jQuery wrapper or something else..\n      if (!isElement(o.boundingBox)) {\n        o.boundingBox = false;\n      }\n\n      // initial containers provided via options are higher priority then by parameter\n      if(o.containers){\n        initialContainers = o.containers;\n      }\n      // sanitize initialContainers\n      initialContainers = makeArray(initialContainers);\n\n      // sanitize o.containersModel\n      o.containersModel = sanitizeContainersModel(o.containersModel);\n\n      // sanitize o.containersFilteredModel\n      if (Array.isArray(o.containersFilteredModel)) {\n        //                  |-------- is 2D array? -----------|\n        o.containersFilteredModel = Array.isArray(o.containersFilteredModel[0]) ? o.containersFilteredModel : [o.containersFilteredModel];\n      } else {\n        o.containersFilteredModel = [];\n      }\n\n      // feed containers groups and optionaly do same for models\n      if (!o.nameSpace) {\n        o.nameSpace = ['dragularCommon'];\n      }\n      if (!Array.isArray(o.nameSpace)) {\n        o.nameSpace = [o.nameSpace];\n      }\n      o.nameSpace.forEach(function eachNameSpace(nameSpace) {\n        if (!shared.containers[nameSpace]) {\n          shared.containers[nameSpace] = [];\n          shared.containersCtx[nameSpace] = [];\n        }\n        var len = initialContainers.length,\n          shLen = shared.containers[nameSpace].length;\n        for (var i = 0; i < len; i++) {\n          shared.containers[nameSpace][i + shLen] = initialContainers[i];\n          shared.containersCtx[nameSpace][i + shLen] = {\n            o: o,\n            m: getContainersModel()[i], // can be undefined\n            fm: o.containersFilteredModel[i] // can be undefined\n          };\n        }\n      });\n    }\n\n    function registerEvents(remove) {\n      var op = remove ? 'off' : 'on';\n      regEvent(docElm, op, 'mouseup', release);\n      // regEvent(docElm, op, 'mousemove', startBecauseMouseMoved);\n\n      initialContainers.forEach(function addMouseDown(container) {\n        regEvent(container, 'on', 'mousedown', grab);\n      });\n\n      if(!remove){ // create dragular DOM events\n        angular.forEach(['dragularenter', 'dragularleave', 'dragularrelease'], function prepareDragOverEvents(name) {\n          var eventName = o.eventNames[name];\n          if(!shared.dragOverEvents[eventName]){\n            if (doc.createEvent) {\n              shared.dragOverEvents[eventName] = doc.createEvent('HTMLEvents');\n              shared.dragOverEvents[eventName].initEvent(eventName, true, true);\n            } else {\n              shared.dragOverEvents[eventName] = doc.createEventObject();\n              shared.dragOverEvents[eventName].eventType = eventName;\n            }\n          }\n        });\n      }\n    }\n\n    // Event handlers functions (end of initial functions): -----------------------------------------------------------------------------------------------------------------\n\n    function grab(e) {\n      // filter some odd situations\n      if (whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey) {\n        return; // we only care about honest-to-god left clicks and touch events\n      }\n\n      // set itial values\n      shared.moveX = e.clientX;\n      shared.moveY = e.clientY;\n\n      var context = canStart(e.target);\n      if (!context || !context.item) {\n        return;\n      }\n\n      shared.grabbed = context;\n      eventualMovements();\n      if (e.type === 'mousedown') {\n        if (isInput(context.item)) { // see also: https://github.com/bevacqua/dragula/issues/208\n          context.item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176\n        } else {\n          e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\n        }\n      }\n    }\n\n    function release(e) {\n      ungrab();\n      if (!drake.dragging) {\n        return;\n      }\n\n      shared.clientX = getCoord('clientX', e);\n      shared.clientY = getCoord('clientY', e);\n\n      var elementBehindCursor = getElementBehindPoint(shared.mirror, shared.clientX, shared.clientY),\n        dropTarget = findDropTarget(elementBehindCursor, shared.clientX, shared.clientY);\n\n      if (dropTarget && ((shared.copy && g(o.copySortSource)) || (!shared.copy || dropTarget !== shared.source))) {\n        // found valid target and (is not copy case or target is not initial container)\n        drop(shared.item, dropTarget);\n      } else if (g(o.removeOnSpill)) {\n        remove();\n      } else {\n        cancel();\n      }\n\n      // after release there is no container hovered\n      shared.target = null;\n\n      if (shared.lastElementBehindCursor) {\n        fireEvent(shared.lastElementBehindCursor, shared.dragOverEvents.dragularrelease, elementBehindCursor);\n      }\n\n      if (o.scope) {\n        o.scope.$emit(o.eventNames.dragularrelease, shared.item, shared.source);\n      }\n    }\n\n    // Main logic functions (end of event handler functions): -----------------------------------------------------------------------------------------------------------------\n\n    function isContainer(el) {\n      if(!el){\n        return false;\n      }\n      var i = o.nameSpace.length;\n      while (i--) {\n        if (shared.containers[o.nameSpace[i]].indexOf(el) !== -1) {\n          return true;\n        }\n      }\n      if (o.isContainer(el)) {\n        shared.tempModel = o.isContainerModel(el);\n        return true;\n      } else {\n        shared.tempModel = null;\n      }\n      return false;\n    }\n\n    function getContainersModel() {\n      return (typeof(o.containersModel) === 'function') ? sanitizeContainersModel(o.containersModel(drake, shared)) : o.containersModel;\n    }\n\n    function removeContainers(all) {\n      $rootScope.$applyAsync(function applyDestroyed() {\n        var changes = Array.isArray(all) ? all : makeArray(all);\n        changes.forEach(function forEachContainer(container) {\n          angular.forEach(o.nameSpace, function forEachNs(nameSpace) {\n            var index;\n            index = shared.containers[nameSpace].indexOf(container);\n            shared.containers[nameSpace].splice(index, 1);\n            shared.containersCtx[nameSpace].splice(index, 1);\n          });\n        });\n      });\n    }\n\n    function eventualMovements(remove) {\n      var op = remove ? 'off' : 'on';\n      regEvent(docElm, op, 'mousemove', startBecauseMouseMoved);\n    }\n\n    function movements(remove) {\n      var op = remove ? 'off' : 'on';\n      regEvent(docElm, op, 'selectstart', preventGrabbed); // IE8\n      regEvent(docElm, op, 'click', preventGrabbed);\n      regEvent(docElm, op, 'touchmove', preventGrabbed); // fixes touch devices scrolling while drag\n    }\n\n    function destroy() {\n      registerEvents(true);\n      removeContainers(initialContainers);\n      release({});\n    }\n\n    function startBecauseMouseMoved(e) {\n      if (!shared.grabbed || drake.dragging) {\n        return;\n      }\n      if (whichMouseButton(e) === 0) {\n        release({});\n        return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope\n      }\n      // truthy check fixes dragula-#239, equality fixes dragula-#207\n      if (e.clientX && e.clientX === shared.moveX && e.clientY && e.clientY === shared.moveY) {\n        return;\n      }\n      if (g(o.ignoreInputTextSelection)) {\n        var clientX = getCoord('clientX', e),\n          clientY = getCoord('clientY', e),\n          elementBehindCursor = doc.elementFromPoint(clientX, clientY);\n        if (isInput(elementBehindCursor)) {\n          return;\n        }\n      }\n\n      var grabbed = shared.grabbed; // calling end() unsets shared.grabbed\n      eventualMovements('remove'); // remove mousemove listener\n      movements();\n      end();\n      start(grabbed);\n\n      // automaticly detect direction of elements if not set in options\n      if (!o.direction && getParent(shared.sourceItem)) {\n        var parent = shared.sourceItem.parentNode,\n          parentHeight = parent.offsetHeight,\n          parentWidth = parent.offsetWidth,\n          childHeight = shared.sourceItem.clientHeight,\n          childWidth = shared.sourceItem.clientWidth;\n        o.direction = parentHeight / childHeight < parentWidth / childWidth ? 'horizontal' : 'vertical';\n      }\n\n      // get initial coordinates, used to render shared.mirror for first time\n      var offset = getOffset(shared.sourceItem);\n      shared.offsetX = getCoord('pageX', e) - offset.left;\n      shared.offsetY = getCoord('pageY', e) - offset.top;\n      shared.clientX = getCoord('clientX', e);\n      shared.clientY = getCoord('clientY', e);\n\n      // limiting area of shared.mirror movement, get initial coordinates\n      if (o.boundingBox) {\n        shared.offsetXr = getCoord('pageX', e) - offset.right;\n        shared.offsetYb = getCoord('pageY', e) - offset.bottom;\n      }\n\n      e.preventDefault();\n\n      addClass(shared.item, o.classes.transit);\n      renderMirrorImage();\n      // initial position\n      shared.mirror.style.left = shared.clientX - shared.offsetX + 'px';\n      shared.mirror.style.top = shared.clientY - shared.offsetY + 'px';\n\n      drag(e);\n    }\n\n    function canStart(item) {\n      if (drake.dragging && shared.mirror) {\n        console.log('usecase?');\n        return; // already dragging\n      }\n\n      var handle = item;\n      while (getParent(item) && !isContainer(getParent(item))) {\n        // break loop if user tries to drag item which is considered invalid handle\n        if (o.invalid(item, handle)) {\n          return;\n        }\n        item = getParent(item); // drag target should be immediate child of container\n        if (!item) {\n          return;\n        }\n      }\n\n      var source = getParent(item);\n      if (!source ||\n        o.invalid(item, handle) ||\n        !o.moves(item, source, handle, nextEl(item))) {\n        return;\n      }\n\n      return {\n        item: item,\n        source: source\n      };\n    }\n\n    function manualStart(item) {\n      var context = canStart(item);\n      if (context) {\n        start(context);\n      }\n    }\n\n    function start(context) {\n      shared.sourceItem = shared.item = context.item;\n      shared.source = context.source;\n      shared.initialSibling = shared.currentSibling = nextEl(context.item);\n\n      if (g(o.copy, [context.item, context.source])) {\n        shared.item = context.item.cloneNode(true);\n        shared.copy = true;\n        if (o.scope) {\n          o.scope.$emit(o.eventNames.dragularcloned, shared.item, context.item);\n        }\n      } else {\n        shared.copy = false;\n      }\n\n      // prepare models operations\n      var containerIndex = initialContainers.indexOf(context.source);\n      shared.sourceModel = getContainersModel()[containerIndex];\n\n      shared.sourceFilteredModel = o.containersFilteredModel[containerIndex];\n      shared.initialIndex = domIndexOf(context.item, context.source);\n\n      drake.dragging = true;\n      if (o.scope) {\n        o.scope.$emit(o.eventNames.dragulardrag, shared.sourceItem, shared.source);\n      }\n\n      return true;\n    }\n\n    function end() {\n      if (!drake.dragging || !shared.item) {\n        return;\n      }\n      drop(shared.item, getParent(shared.item));\n    }\n\n    function ungrab() {\n      shared.grabbed = false;\n      eventualMovements('remove');\n      movements('remove');\n    }\n\n    function drop(item, target) {\n      if (shared.copy && g(o.copySortSource) && target === shared.source && getParent(item)) {\n        item.parentNode.removeChild(shared.sourceItem);\n      }\n\n      if (shared.sourceModel && !isInitialPlacement(target)) {\n\n        var dropIndex = domIndexOf(item, target);\n        if(shared.targetCtx.fm){ // target has filtered model\n          // convert index from index-in-filteredModel to index-in-model\n          dropIndex = shared.targetCtx.m.indexOf(shared.targetCtx.fm[dropIndex]);\n        }\n        if(shared.sourceFilteredModel){ // target has filtered model\n          // convert index from index-in-filteredModel to index-in-model\n          shared.initialIndex = shared.sourceModel.indexOf(shared.sourceFilteredModel[shared.initialIndex]);\n        }\n        $rootScope.$applyAsync(function applyDrop() {\n          if (target === shared.source) {\n            shared.sourceModel.splice(dropIndex, 0, shared.sourceModel.splice(shared.initialIndex, 1)[0]);\n          } else {\n            shared.dropElmModel = shared.copy && !o.dontCopyModel ? angular.copy(shared.sourceModel[shared.initialIndex]) : shared.sourceModel[shared.initialIndex];\n\n            if (!shared.tempModel) {\n              shared.targetModel = shared.targetCtx.m;\n            } else {\n              shared.targetModel = shared.tempModel;\n            }\n\n            target.removeChild(item); // element must be removed for ngRepeat to apply correctly\n\n            if (!shared.copy) {\n              shared.sourceModel.splice(shared.initialIndex, 1);\n            }\n            shared.targetModel.splice(dropIndex, 0, shared.dropElmModel);\n          }\n\n          if (getParent(item)) {\n            item.parentNode.removeChild(item);\n          }\n\n          emitDropEvent();\n          cleanup();\n        });\n      } else {\n        emitDropEvent();\n        cleanup();\n      }\n\n      function emitDropEvent() {\n        if (o.scope) {\n          if (isInitialPlacement(target)) {\n            o.scope.$emit(o.eventNames.dragularcancel, item, shared.source, shared.sourceModel, shared.initialIndex);\n          } else {\n            o.scope.$emit(o.eventNames.dragulardrop, item, target, shared.source, shared.sourceModel, shared.initialIndex, shared.targetModel, dropIndex);\n          }\n        }\n      }\n    }\n\n    function remove() {\n      if (!drake.dragging) {\n        return;\n      }\n      var parent = getParent(shared.item);\n\n      if (parent) {\n        parent.removeChild(shared.item);\n      }\n\n      if (shared.sourceModel) {\n        $rootScope.$applyAsync(function removeModel() {\n          shared.sourceModel.splice(shared.initialIndex, 1);\n          cleanup();\n        });\n      }\n\n      if (o.scope) {\n        o.scope.$emit(shared.copy ? o.eventNames.dragularcancel : o.eventNames.dragularremove, shared.item, parent, shared.sourceModel, shared.initialIndex);\n      }\n      if (!shared.sourceModel) {\n        cleanup();\n      }\n    }\n\n    function cancel(revert) {\n      if (!drake.dragging) {\n        return;\n      }\n      var reverts = arguments.length > 0 ? revert : g(o.revertOnSpill),\n        parent = getParent(shared.item);\n\n      var initial = isInitialPlacement(parent);\n      if (!initial && !shared.copy && reverts) {\n        shared.source.insertBefore(shared.item, shared.initialSibling);\n      }\n      if (shared.sourceModel && !shared.copy && !reverts) {\n        drop(shared.item, parent);\n      } else if (o.scope) {\n        if (initial || reverts) {\n          o.scope.$emit(o.eventNames.dragularcancel, shared.item, shared.source);\n        }\n      }\n\n      if (!shared.sourceModel || shared.copy || reverts || initial) {\n        cleanup();\n      }\n    }\n\n    function cleanup() {\n      ungrab();\n      removeMirrorImage();\n\n      if (shared.item) {\n        rmClass(shared.item, o.classes.transit);\n      }\n\n      drake.dragging = false;\n\n      if (g(o.removeOnSpill) === true) {\n        spillOut();\n      }\n\n      if (o.scope) {\n        if(shared.lastDropTarget){\n         o.scope.$emit(o.eventNames.dragularout, shared.item, shared.lastDropTarget, shared.source);\n        }\n        o.scope.$emit(o.eventNames.dragulardragend, shared.item);\n      }\n\n      shared.source = shared.item = shared.sourceItem = shared.initialSibling = shared.currentSibling = shared.sourceModel = null;\n      shared.initialIndex = shared.currentIndex = shared.lastDropTarget = shared.tempModel = shared.targetModel = null;\n      shared.dropElmModel = shared.targetCtx = shared.copy = shared.moveX = shared.moveY = null;\n    }\n\n    // is item currently placed in original container and original position?\n    function isInitialPlacement(target, s) { // watch performance - running each move several times!\n      var sibling = s || (shared.mirror ? shared.currentSibling : nextEl(shared.item));\n      return target === shared.source && sibling === shared.initialSibling;\n    }\n\n    // find valid drop container\n    function findDropTarget(elementBehindCursor, clientX, clientY) {  // watch performance - running each move!\n      var target = elementBehindCursor;\n\n      while (target && !accepted()) {\n        target = getParent(target);\n      }\n      return target;\n\n      function accepted() {\n        var accepts = false;\n\n        if (isContainer(target)) { // is droppable?\n\n          var immediate = getImmediateChild(target, elementBehindCursor),\n            reference = getReference(target, immediate, clientX, clientY),\n            initial = isInitialPlacement(target, reference),\n            i = o.nameSpace.length;\n\n          while (i--) {\n            if (shared.containers[o.nameSpace[i]].indexOf(target) !== -1) {\n              shared.targetCtx = shared.containersCtx[o.nameSpace[i]][shared.containers[o.nameSpace[i]].indexOf(target)];\n              break;\n            }\n            if (!shared.targetCtx) {\n              shared.targetCtx = shared.containersCtx.dragularCommon[shared.containers.dragularCommon.indexOf(target)];\n            }\n          }\n\n          accepts = initial ||\n            (shared.targetCtx.o.accepts(shared.item, target, shared.source, reference, shared.sourceModel, shared.initialIndex) &&\n              o.canBeAccepted(shared.item, target, shared.source, reference, shared.sourceModel, shared.initialIndex));\n\n          if (shared.target !== target) { // used for scroll issue\n            shared.target = target;\n          }\n        }\n        return accepts;\n      }\n    }\n\n    function drag(e) { // watch performance - running each move!\n      if (!shared.mirror) {\n        return;\n      }\n\n      // update coordinates\n      shared.clientX = getCoord('clientX', e);\n      shared.clientY = getCoord('clientY', e);\n\n      // count mirror coordiates\n      var x = shared.clientX - shared.offsetX,\n        y = shared.clientY - shared.offsetY,\n        pageX,\n        pageY,\n        offsetBox;\n\n      // fill extra properties if boundingBox is used\n      if (o.boundingBox) {\n        pageX = getCoord('pageX', e);\n        pageY = getCoord('pageY', e);\n        offsetBox = getOffset(o.boundingBox);\n      }\n\n      if (!o.lockY) {\n        if (!o.boundingBox || (pageX > offsetBox.left + shared.offsetX && pageX < offsetBox.right + shared.offsetXr)) {\n          shared.mirror.style.left = x + 'px';\n        } else if (o.boundingBox) { // check again in case user scrolled the view\n          if (pageX < offsetBox.left + shared.offsetX) {\n            shared.mirror.style.left = shared.clientX - (pageX - offsetBox.left) + 'px';\n          } else {\n            shared.mirror.style.left = shared.clientX - shared.mirrorWidth - (pageX - offsetBox.right) + 'px';\n          }\n        }\n      }\n      if (!o.lockX) {\n        if (!o.boundingBox || (pageY > offsetBox.top + shared.offsetY && pageY < offsetBox.bottom + shared.offsetYb)) {\n          shared.mirror.style.top = y + 'px';\n        } else if (o.boundingBox) { // check again in case user scrolled the view\n          if (pageY < offsetBox.top + shared.offsetY) {\n            shared.mirror.style.top = shared.clientY - (pageY - offsetBox.top) + 'px';\n          } else {\n            shared.mirror.style.top = shared.clientY - shared.mirrorHeight - (pageY - offsetBox.bottom) + 'px';\n          }\n        }\n      }\n\n      var elementBehindCursor = getElementBehindPoint(shared.mirror, shared.clientX, shared.clientY),\n        dropTarget = findDropTarget(elementBehindCursor, shared.clientX, shared.clientY),\n        changed = dropTarget !== shared.lastDropTarget;\n\n      if (elementBehindCursor !== shared.lastElementBehindCursor) {\n        fireEvent(elementBehindCursor, shared.dragOverEvents.dragularenter, !!dropTarget);\n        if (shared.lastElementBehindCursor) {\n          fireEvent(shared.lastElementBehindCursor, shared.dragOverEvents.dragularleave, elementBehindCursor);\n        }\n        shared.lastElementBehindCursor = elementBehindCursor;\n      }\n\n      if (changed) {\n        if (shared.lastDropTarget) {\n          moved('out');\n        }\n        shared.lastDropTarget = dropTarget;\n        moved('over');\n      }\n\n      // do not copy in same container\n      if (dropTarget === shared.source && shared.copy && !g(o.copySortSource)) {\n        if (getParent(shared.item)) {\n          shared.item.parentNode.removeChild(shared.item);\n        }\n        return;\n      }\n\n      var reference,\n        immediate = getImmediateChild(dropTarget, elementBehindCursor);\n\n      if (immediate !== null) {\n        reference = getReference(dropTarget, immediate, shared.clientX, shared.clientY);\n      } else if (g(o.revertOnSpill) === true && !shared.copy) {\n        // the case that mirror is not over valid target and reverting is on and copy is off\n        reference = shared.initialSibling;\n        dropTarget = shared.source;\n      } else {\n        // the case that mirror is not over valid target and removing is on or copy is on\n        if (shared.copy && getParent(shared.item)) {\n          // remove item or copy of item\n          shared.item.parentNode.removeChild(shared.item);\n        }\n        return;\n      }\n\n      if (reference === null ||\n        reference !== shared.item &&\n        reference !== nextEl(shared.item) &&\n        reference !== shared.currentSibling) {\n        // moving item/copy to new container from previous one\n        shared.currentSibling = reference;\n\n        dropTarget.insertBefore(shared.item, reference); // if reference is null item is inserted at the end\n\n        if (o.scope) {\n          o.scope.$emit(o.eventNames.dragularshadow, shared.item, dropTarget);\n        }\n      }\n\n      function moved(type) {\n        if (o.scope) {\n          o.scope.$emit(o.eventNames['dragular' + type], shared.item, shared.lastDropTarget, shared.source);\n        }\n        if (g(o.removeOnSpill) === true) {\n          type === 'over' ? spillOver() : spillOut();\n        }\n      }\n    }\n\n    function spillOver() {\n      rmClass(shared.item, o.classes.hide);\n    }\n\n    function spillOut() {\n      if (drake.dragging) {\n        addClass(shared.item, o.classes.hide);\n      }\n    }\n\n    function scrollContainer(e) {\n      if (shared.target) {\n        var before = shared.target.scrollTop;\n        shared.target.scrollTop += e.deltaY;\n        // block scroll of the document when container can be scrolled\n        if (before !== shared.target.scrollTop) {\n          e.stopPropagation();\n          e.preventDefault();\n        }\n      }\n    }\n\n    function renderMirrorImage() {\n      if (shared.mirror) {\n        return;\n      }\n      var rect = shared.sourceItem.getBoundingClientRect();\n      shared.mirror = shared.sourceItem.cloneNode(true);\n      shared.mirrorWidth = rect.width;\n      shared.mirrorHeight = rect.height;\n      shared.mirror.style.width = getRectWidth(rect) + 'px';\n      shared.mirror.style.height = getRectHeight(rect) + 'px';\n      rmClass(shared.mirror, o.classes.transit);\n      addClass(shared.mirror, o.classes.mirror);\n      o.mirrorContainer.appendChild(shared.mirror);\n      regEvent(docElm, 'on', 'mousemove', drag);\n      addClass(doc.body, o.classes.unselectable);\n      regEvent(shared.mirror, 'on', 'wheel', scrollContainer);\n      if (o.scope) {\n        o.scope.$emit(o.eventNames.dragularcloned, shared.mirror, shared.sourceItem);\n      }\n    }\n\n    function removeMirrorImage() {\n      if (shared.mirror) {\n        rmClass(doc.body, o.classes.unselectable);\n        regEvent(docElm, 'off', 'mousemove', drag);\n        regEvent(shared.mirror, 'off', 'wheel', scrollContainer);\n        if(getParent(shared.mirror)){\n          shared.mirror.parentNode.removeChild(shared.mirror);\n        }\n        shared.mirror = null;\n      }\n    }\n\n    function getImmediateChild(dropTarget, target) { // watch performance - running each move several times!\n      var immediate = target;\n      while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {\n        immediate = getParent(immediate);\n      }\n      if (immediate === docElm) {\n        return null;\n      }\n      return immediate;\n    }\n\n    function getReference(dropTarget, target, x, y) { // watch performance - running each move several times!\n      var horizontal = o.direction === 'horizontal';\n      return target !== dropTarget ? inside() : outside();\n\n      function outside() { // slower, but able to figure out any position\n        var len = dropTarget.children.length,\n          i, el, rect;\n        for (i = 0; i < len; i++) {\n          el = dropTarget.children[i];\n          rect = el.getBoundingClientRect();\n          if (horizontal && rect.left > x) {\n            return el;\n          }\n          if (!horizontal && rect.top > y) {\n            return el;\n          }\n        }\n        return null;\n      }\n\n      function inside() { // faster, but only available if dropped inside a child element\n        var rect = target.getBoundingClientRect();\n        if (horizontal) {\n          return resolve(x > rect.left + getRectWidth(rect) / 2);\n        }\n        return resolve(y > rect.top + getRectHeight(rect) / 2);\n      }\n\n      function resolve(after) {\n        return after ? nextEl(target) : target;\n      }\n    }\n\n    function getElementBehindPoint(point, x, y) { // watch performance - running each move!\n      var p = point || {},\n        state = p.className,\n        el;\n      p.className += ' ' + o.classes.hide;\n      el = doc.elementFromPoint(x, y);\n      p.className = state;\n      return el;\n    }\n  } // end of service\n\n  /****************************************************************************************************************************/\n  /****************************************************************************************************************************/\n  /****************************************************************************************************************************/\n\n  // HELPERS FUNCTIONS:\n\n  function regEvent(el, op, type, fn) {\n    var touch = {\n        mouseup: 'touchend',\n        mousedown: 'touchstart',\n        mousemove: 'touchmove'\n      },\n      pointers = {\n        mouseup: 'pointerup',\n        mousedown: 'pointerdown',\n        mousemove: 'pointermove'\n      },\n      microsoft = {\n        mouseup: 'MSPointerUp',\n        mousedown: 'MSPointerDown',\n        mousemove: 'MSPointerMove'\n      },\n      $el = angular.element(el);\n\n    if (global.navigator.pointerEnabled) {\n      $el[op](pointers[type], fn);\n    } else if (global.navigator.msPointerEnabled) {\n      $el[op](microsoft[type], fn);\n    } else if (touch[type]) {\n      $el[op](touch[type], fn);\n    }\n    $el[op](type, fn);\n  }\n\n  function never() {\n    return false;\n  }\n\n  function always() {\n    return true;\n  }\n\n  // make array from array-like objects or from single element (based on bevacqua/atoa)\n  function makeArray(all, startIndex) {\n    if (Array.isArray(all)) {\n      return all;\n    }\n    if (all.length) { // is array-like\n      return Array.prototype.slice.call(all, startIndex); // convert to vanilla js array\n    } else { // is one element\n      return [all];\n    }\n  }\n\n  function whichMouseButton (e) {\n    if (e.touches !== void 0) { return e.touches.length; }\n    if (e.buttons !== undefined) { return e.buttons; }\n    if (e.which !== undefined) { return e.which; }\n    var button = e.button;\n    if (button !== undefined) { // see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575\n      return button & 1 ? 1 : button & 2 ? 3 : (button & 4 ? 2 : 0);\n    }\n  }\n\n  function preventGrabbed(e) {\n    if (shared.grabbed) {\n      e.preventDefault();\n    }\n  }\n\n  function getScroll(scrollProp, offsetProp) {\n    if (typeof window[offsetProp] !== 'undefined') {\n      return window[offsetProp];\n    }\n    if (docElm.clientHeight) {\n      return docElm[scrollProp];\n    }\n    return doc.body[scrollProp];\n  }\n\n  function getOffset(el) { // watch performance - running each move!\n    var rect = el.getBoundingClientRect(),\n      scrollTop = getScroll('scrollTop', 'pageYOffset'),\n      scrollLeft = getScroll('scrollLeft', 'pageXOffset');\n    return {\n      left: rect.left + scrollLeft,\n      right: rect.right + scrollLeft,\n      top: rect.top + scrollTop,\n      bottom: rect.bottom + scrollTop\n    };\n  }\n\n  function getRectWidth(rect) {\n    return rect.width || (rect.right - rect.left);\n  }\n\n  function getRectHeight(rect) {\n    return rect.height || (rect.bottom - rect.top);\n  }\n\n  function getEmptyObject() {\n    return {};\n  }\n\n  function nextEl(el) {\n    return el.nextElementSibling || manually();\n\n    function manually() {\n      var sibling = el;\n      do {\n        sibling = sibling.nextSibling;\n      } while (sibling && sibling.nodeType !== 1);\n      return sibling;\n    }\n  }\n\n  //Cannot use angular.isElement because we need to check plain dom element, no jQlite wrapped\n  function isElement(obj) {\n    return (\n      typeof HTMLElement === 'object' ? obj instanceof HTMLElement : //DOM2\n      obj && typeof obj === 'object' && obj !== null && obj.nodeType === 1 && typeof obj.nodeName === 'string'\n    );\n  }\n\n  function lookupClass(className) {\n    var cached = shared.classesCache[className];\n    if (cached) {\n      cached.lastIndex = 0;\n    } else {\n      shared.classesCache[className] = cached = new RegExp('(?:^|\\\\s)' + className + '(?:\\\\s|$)', 'g');\n    }\n    return cached;\n  }\n\n  function addClass(el, className) {\n    var current = el.className;\n    if (!current.length) {\n      el.className = className;\n    } else if (!lookupClass(className).test(current)) {\n      el.className += ' ' + className;\n    }\n  }\n\n  function rmClass(el, className) {\n    el.className = el.className.replace(lookupClass(className), ' ').trim();\n  }\n\n  function getEventHost(e) {\n    // on touchend event, we have to use `e.changedTouches`\n    // see http://stackoverflow.com/questions/7192563/touchend-event-properties\n    // see https://github.com/bevacqua/dragula/issues/34\n    if (e.targetTouches && e.targetTouches.length) {\n      return e.targetTouches[0];\n    }\n    if (e.changedTouches && e.changedTouches.length) {\n      return e.changedTouches[0];\n    }\n    return e;\n  }\n\n  function getCoord(coord, e) { // watch performance - running each move several times!\n    var host = getEventHost(e);\n    var missMap = {\n      pageX: 'clientX', // IE8\n      pageY: 'clientY' // IE8\n    };\n    if (coord in missMap && !(coord in host) && missMap[coord] in host) {\n      coord = missMap[coord];\n    }\n\n    // Adding support for touch events, as they are not functional in the original\n    if (!host.type || host.type.indexOf('touch') < 0) {\n      return host[coord];\n    } else {\n      if (host.type.indexOf('end') === -1) {\n        // No clientX or clientY in a touch event\n        return host.originalEvent.touches[0][coord.replace('client', 'page')];\n      }\n      // Nothing should happen for touchend\n      return false;\n    }\n  }\n\n  function getParent (el) { // watch performance - running each move!\n    return el.parentNode === document ? null : el.parentNode;\n  }\n\n  function isInput (el) {\n    return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || isEditable(el);\n  }\n\n  function isEditable (el) {\n    if (!el) { return false; } // no parents were editable\n    if (el.contentEditable === 'false') { return false; } // stop the lookup\n    if (el.contentEditable === 'true') { return true; } // found a contentEditable element in the chain\n    return isEditable(getParent(el)); // contentEditable is set to 'inherit'\n  }\n\n  function domIndexOf(child, parent) {\n    return Array.prototype.indexOf.call(angular.element(parent).children(), child);\n  }\n\n  function fireEvent(target, e, extra) { // watch performance - running each move!\n    if (!target) {\n      return;\n    }\n    shared.extra = extra;\n    if (target.dispatchEvent) {\n      target.dispatchEvent(e);\n    } else {\n      target.fireEvent('on' + e.eventType, e);\n    }\n  }\n\n  function getBool(prop, args, context){\n    if(angular.isFunction(prop)){\n      return !!prop.apply(context || this, args || shared);\n    }else{\n      return !!prop;\n    }\n  }\n\n};\n\ndragularService.$inject = ['$rootScope'];\n\nmodule.exports = dragularService;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}]},{},[2])(2)\n});"],"sourceRoot":"/source/"}