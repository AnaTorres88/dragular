{"version":3,"sources":["dragular.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","dragularModule","directive","dragularService","restrict","link","$scope","iElm","iAttrs","tryJson","json","JSON","parse","options","$eval","dragular","dragularModel","angular","extend","containersModel","./dragularModule",2,"dragularDirective","./dragularDirective.js","./dragularService.js",3,"factory","$rootScope","regEvent","el","op","type","fn","touch","mouseup","mousedown","mousemove","$el","element","never","always","getRectWidth","rect","width","right","left","getRectHeight","height","bottom","top","getEmptyObject","nextEl","manually","sibling","nextSibling","nodeType","nextElementSibling","isElement","HTMLElement","nodeName","lookupClass","className","cached","shared","classesCache","lastIndex","RegExp","addClass","current","test","rmClass","replace","trim","getEventHost","targetTouches","changedTouches","getCoord","coord","host","missMap","pageX","pageY","indexOf","originalEvent","touches","whichMouseButton","undefined","buttons","which","button","getParent","parentNode","document","isInput","tagName","isEditable","contentEditable","domIndexOf","child","parent","Array","prototype","children","fireEvent","target","extra","dispatchEvent","eventType","containersCtx","containers","mirror","source","item","copy","sourceItem","sourceModel","targetCtx","targetModel","lastDropTarget","offsetX","offsetY","moveX","moveY","offsetXr","offsetYb","clientX","clientY","mirrorWidth","mirrorHeight","initialSibling","currentSibling","initialIndex","currentIndex","isContainerModel","dragOverEvents","lastElementBehindCursor","grabbed","serviceFn","arg0","arg1","processServiceArguments","arguments","isArray","initialContainers","querySelectorAll","extendDefaultOptions","classes","defaultClasses","eventNames","defaultEventNames","processOptionsObject","boundingBox","makeArray","nameSpace","forEach","len","shLen","m","registerEvents","remove","docElm","release","container","grab","name","eventName","doc","createEvent","initEvent","createEventObject","isContainer","all","startIndex","slice","removeContainers","$applyAsync","changes","index","splice","eventualMovements","startBecauseMouseMoved","movements","preventGrabbed","destroy","preventDefault","window","event","metaKey","ctrlKey","context","canStart","focus","drake","dragging","ignoreInputTextSelection","elementBehindCursor","elementFromPoint","end","start","direction","parentHeight","offsetHeight","parentWidth","offsetWidth","childHeight","clientHeight","childWidth","clientWidth","offset","getOffset","transit","renderMirrorImage","style","drag","handle","invalid","moves","manualStart","isCopy","cloneNode","scope","$emit","dragularcloned","containerIndex","dragulardrag","invalidTarget","drop","ungrab","getElementBehindPoint","dropTarget","findDropTarget","copySortSource","removeOnSpill","cancel","dragularrelease","emitDropEvent","isInitialPlacement","dragularcancel","dragulardrop","dropIndex","removeChild","dropElm","dropElmModel","cleanup","dragularremove","revert","reverts","revertOnSpill","initial","insertBefore","removeMirrorImage","spillOut","dragularout","dragulardragend","accepted","accepts","immediate","getImmediateChild","reference","getReference","dragularCommon","canBeAccepted","moved","spillOver","over","changed","out","offsetBox","x","y","lockY","lockX","dragularenter","dragularleave","dragularshadow","hide","scrollContainer","before","scrollTop","deltaY","stopPropagation","getBoundingClientRect","mirrorContainer","appendChild","body","unselectable","outside","horizontal","inside","resolve","after","getScroll","scrollProp","offsetProp","scrollLeft","point","p","state","documentElement","dragularover","cleanEnviroment"],"mappings":"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","file":"dragular.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/* global angular */\n'use strict';\n\n/**\n * dragular Directive by Luckylooke https://github.com/luckylooke/dragular\n * Angular version of dragula https://github.com/bevacqua/dragula\n */\n var dragularModule = require('./dragularModule');\n\ndragularModule.directive('dragular', [\"dragularService\", function(dragularService) {\n  return {\n    restrict: 'A',\n    link: function($scope, iElm, iAttrs) {\n\n      var options = $scope.$eval(iAttrs.dragular) || tryJson(iAttrs.dragular) || {};\n\n      function tryJson(json) {\n        try { // I dont like try catch solutions but I havent find sattisfying way of chcecking json validity.\n          return JSON.parse(json);\n        } catch (e) {\n          return undefined;\n        }\n      }\n\n      if(iAttrs.dragularModel){\n        options = angular.extend({containersModel: $scope.$eval(iAttrs.dragularModel)}, options);\n      }else if(options && options.containersModel && typeof options.containersModel === 'string'){\n        options.containersModel = $scope.$eval(options.containersModel);\n      }\n\n      dragularService(iElm[0], options);\n    }\n  };\n}]);\n\n},{\"./dragularModule\":2}],2:[function(require,module,exports){\n/* global angular */\n'use strict';\n\n\n\n/**\n * Dragular 3.3.1 by Luckylooke https://github.com/luckylooke/dragular\n * Angular version of dragula https://github.com/bevacqua/dragula\n */\nmodule.exports = angular.module('dragularModule', []);\n\n({\"dragularDirective\":require(\"./dragularDirective.js\"),\"dragularService\":require(\"./dragularService.js\")});\n\n},{\"./dragularDirective.js\":1,\"./dragularService.js\":3}],3:[function(require,module,exports){\n/* global angular */\n'use strict';\n\n/**\n * dragular Service by Luckylooke https://github.com/luckylooke/dragular\n * Angular version of dragula https://github.com/bevacqua/dragula\n */\n\nvar dragularModule = require('./dragularModule');\n\ndragularModule.factory('dragularService', [\"$rootScope\", function dragula($rootScope) {\n\n  var shared = {\n      classesCache: {}, // classes lookup cache\n      containersCtx: {}, // containers model\n      containers: {}, // containers managed by the drake\n      mirror: null, // mirror image\n      source: null, // source container\n      item: null, // item being dragged\n      copy: null, // isCopy flag\n      sourceItem: null, // item originaly dragged if copy is enabled\n      sourceModel: null, // source container model\n      target: null, // droppable container under drag item\n      targetCtx: null, // target container context\n      targetModel: null, // target container model\n      lastDropTarget: null, // last container item was over\n      offsetX: null, // reference x\n      offsetY: null, // reference y\n      moveX: null, // reference move x\n      moveY: null, // reference move y\n      offsetXr: null, // reference x right for boundingBox feature\n      offsetYb: null, // reference y bottom for boundingBox feature\n      clientX: null, // cache client x, init at grab, update at drag\n      clientY: null, // cache client y, init at grab, update at drag\n      mirrorWidth: null, // mirror width for boundingBox feature\n      mirrorHeight: null, // mirror height for boundingBox feature\n      initialSibling: null, // reference sibling when grabbed\n      currentSibling: null, // reference sibling now\n      initialIndex: null, // reference model index when grabbed\n      currentIndex: null, // reference model index now\n      isContainerModel: null, // if o.isContainer is used, model can be provided as well, here it is kept\n      dragOverEvents: {}, // drag over events fired on element behind cursor\n      lastElementBehindCursor: null, // last element behind cursor\n      grabbed: null // holds mousedown context until first mousemove\n    },\n  // function returned as service\n    serviceFn = function(arg0, arg1) {\n      var initialContainers = arg0 || [],\n        options = arg1 || {},\n        // abbreviations\n        doc = document,\n        body = doc.body,\n        docElm = doc.documentElement,\n        // defaults\n        defaultClasses = {\n          mirror: 'gu-mirror',\n          hide: 'gu-hide',\n          unselectable: 'gu-unselectable',\n          transit: 'gu-transit'\n        },\n        defaultEventNames = {\n          // drag-over DOM events\n          dragularenter: 'dragularenter',\n          dragularleave: 'dragularleave',\n          dragularrelease: 'dragularrelease',\n          // $scope events\n          dragularcloned: 'dragularcloned',\n          dragulardrag: 'dragulardrag',\n          dragularcancel: 'dragularcancel',\n          dragulardrop: 'dragulardrop',\n          dragularremove: 'dragularremove',\n          dragulardragend: 'dragulardragend',\n          dragularshadow: 'dragularshadow',\n          dragularover: 'dragularover',\n          dragularout: 'dragularout'\n        },\n        o = { // options with defaults\n          // classes used by dragular\n          classes: defaultClasses,\n          // event names used by dragular\n          eventNames: defaultEventNames,\n          // initial containers provided via options object (are provided via parameter by default)\n          containers: false,\n          // can drag start?\n          moves: always,\n          // can target accept dragged item? (target context used)\n          accepts: always,\n          // can be dragged item accepted by target? (source context used)\n          canBeAccepted: always,\n          // potential target can be forced to be container by custom logic\n          isContainer: never,\n          // dragged item will be copy of source? flag or function\n          copy: false,\n          // target (in)validity function\n          invalid: invalidTarget,\n          // item returns to original place\n          revertOnSpill: false,\n          // item will be removed if not placed into valid target\n          removeOnSpill: false,\n          // lock movement into x-axis\n          lockX: false,\n          // lock movement into y-axis\n          lockY: false,\n          // lock movement inside this element boundaries\n          boundingBox: false,\n          // if provided, model will be synced with DOM\n          containersModel: false,\n          // if isContainer function is provided, you can provide also respective model\n          isContainerModel: getEmptyObject,\n          // element for appending mirror\n          mirrorContainer: doc.body,\n          // text selection in inputs wont be considered as drag\n          ignoreInputTextSelection: false\n        };\n\n      processServiceArguments(); // both arguments (containers and options) are optional, this function handle this\n      extendDefaultOptions();\n      processOptionsObject();\n      registerEvents();\n\n      var drake = {\n        containers: shared.containers,\n        containersCtx: shared.containersCtx,\n        isContainer: isContainer,\n        start: manualStart,\n        end: end,\n        cancel: cancel,\n        remove: remove,\n        destroy: destroy,\n        dragging: false\n      };\n\n      return drake;\n\n      // Function definitions: ==============================================================================================================\n\n      function processServiceArguments(){\n        if (arguments.length === 1 && // if there is only one argument we need to distinguish if it is options object or container(s) reference\n            !Array.isArray(arg0) && // array of containers elements\n            !angular.isElement(arg0) && // one container element\n            !arg0[0] && // array-like object with containers elements\n            typeof arg0 !== 'string') { // selector\n          // then arg0 is options object\n          options = arg0 || {};\n          initialContainers = []; // containers are not provided on init\n        } else if (typeof arg0 === 'string') {\n          initialContainers = document.querySelectorAll(arg0);\n        }\n      }\n\n      function extendDefaultOptions(){\n        angular.extend(o, options);\n        if(options.classes){\n          o.classes = angular.extend({}, defaultClasses, options.classes);\n        }\n        if(options.eventNames){\n          o.eventNames = angular.extend({}, defaultEventNames, options.eventNames);\n        }\n      }\n\n      function processOptionsObject(){\n        // bounding box must be pure DOM element, not jQuery wrapper or something else..\n        if (!isElement(o.boundingBox)) {\n          o.boundingBox = false;\n        }\n\n        // initial containers provided via options are higher priority then by parameter\n        if(o.containers){\n          initialContainers = o.containers;\n        }\n        // sanitize initialContainers\n        initialContainers = makeArray(initialContainers);\n\n        // sanitize o.containersModel\n        if (Array.isArray(o.containersModel)) {\n          //                  |-------- is 2D array? -----------|\n          o.containersModel = Array.isArray(o.containersModel[0]) ? o.containersModel : [o.containersModel];\n        } else {\n          o.containersModel = [];\n        }\n\n        // feed containers groups and optionaly shadow it by models\n        if (!o.nameSpace) {\n          o.nameSpace = ['dragularCommon'];\n        }\n        if (!Array.isArray(o.nameSpace)) {\n          o.nameSpace = [o.nameSpace];\n        }\n        o.nameSpace.forEach(function eachNameSpace(nameSpace) {\n          if (!shared.containers[nameSpace]) {\n            shared.containers[nameSpace] = [];\n            shared.containersCtx[nameSpace] = [];\n          }\n          var len = initialContainers.length,\n            shLen = shared.containers[nameSpace].length;\n          for (var i = 0; i < len; i++) {\n            shared.containers[nameSpace][i + shLen] = initialContainers[i];\n            shared.containersCtx[nameSpace][i + shLen] = {\n              o: o,\n              m: o.containersModel[i] // can be undefined\n            };\n          }\n        });\n      }\n\n      function registerEvents(remove) {\n        var op = remove ? 'off' : 'on';\n        regEvent(docElm, op, 'mouseup', release);\n        // regEvent(docElm, op, 'mousemove', startBecauseMouseMoved);\n\n        initialContainers.forEach(function addMouseDown(container) {\n          regEvent(container, 'on', 'mousedown', grab);\n        });\n\n        if(!remove){\n          angular.forEach(['dragularenter', 'dragularleave', 'dragularrelease'], function prepareDragOverEvents(name) {\n            var eventName = o.eventNames[name];\n            if(!shared.dragOverEvents[eventName]){\n              if (doc.createEvent) {\n                shared.dragOverEvents[eventName] = doc.createEvent('HTMLEvents');\n                shared.dragOverEvents[eventName].initEvent(eventName, true, true);\n              } else {\n                shared.dragOverEvents[eventName] = doc.createEventObject();\n                shared.dragOverEvents[eventName].eventType = eventName;\n              }\n            }\n          });\n        }\n      }\n\n      function isContainer(el) {\n        if(!el){\n          return false;\n        }\n        var i = o.nameSpace.length;\n        while (i--) {\n          if (shared.containers[o.nameSpace[i]].indexOf(el) !== -1) {\n            return true;\n          }\n        }\n        if (o.isContainer(el)) {\n          shared.isContainerModel = o.isContainerModel(el);\n          return true;\n        } else {\n          shared.isContainerModel = null;\n        }\n        return false;\n      }\n\n      // make array from array-like objects or from single element (based on bevacqua/atoa)\n      function makeArray(all, startIndex) {\n        if (Array.isArray(all)) {\n          return all;\n        }\n        if (all.length) { // is array-like\n          return Array.prototype.slice.call(all, startIndex);\n        } else { // is one element\n          return [all];\n        }\n      }\n\n      // add or remove containers - deprecated\n      function removeContainers(all) {\n        $rootScope.$applyAsync(function applyDestroyed() {\n          var changes = Array.isArray(all) ? all : makeArray(all);\n          changes.forEach(function forEachContainer(container) {\n            angular.forEach(o.nameSpace, function forEachNs(nameSpace) {\n              var index;\n              index = shared.containers[nameSpace].indexOf(container);\n              shared.containers[nameSpace].splice(index, 1);\n              shared.containersCtx[nameSpace].splice(index, 1);\n            });\n          });\n        });\n      }\n\n      function eventualMovements(remove) {\n        var op = remove ? 'off' : 'on';\n        regEvent(docElm, op, 'mousemove', startBecauseMouseMoved);\n      }\n\n      function movements(remove) {\n        var op = remove ? 'off' : 'on';\n        regEvent(docElm, op, 'selectstart', preventGrabbed); // IE8\n        regEvent(docElm, op, 'click', preventGrabbed);\n        regEvent(docElm, op, 'touchmove', preventGrabbed); // fixes touch devices scrolling while drag\n      }\n\n      function destroy() {\n        registerEvents(true);\n        removeContainers(initialContainers);\n        release({});\n      }\n\n      function preventGrabbed(e) {\n        if (shared.grabbed) {\n          e.preventDefault();\n        }\n      }\n\n      function grab(e) {\n        e = e || window.event;\n        shared.moveX = e.clientX;\n        shared.moveY = e.clientY;\n\n        // filter some odd situations\n        if (whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey) {\n          return; // we only care about honest-to-god left clicks and touch events\n        }\n\n        var context = canStart(e.target);\n        if (!context || !context.item) {\n          return;\n        }\n\n        shared.grabbed = context;\n        eventualMovements();\n        if (e.type === 'mousedown') {\n          if (isInput(context.item)) { // see also: https://github.com/bevacqua/dragula/issues/208\n            context.item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176\n          } else {\n            e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\n          }\n        }\n      }\n\n      function startBecauseMouseMoved(e) {\n        if (!shared.grabbed || drake.dragging) {\n          return;\n        }\n        if (whichMouseButton(e) === 0) {\n          release({});\n          return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope\n        }\n        // truthy check fixes #239, equality fixes #207\n        if (e.clientX && e.clientX === shared.moveX && e.clientY && e.clientY === shared.moveY) {\n          return;\n        }\n        if (o.ignoreInputTextSelection) {\n          var clientX = getCoord('clientX', e),\n            clientY = getCoord('clientY', e),\n            elementBehindCursor = doc.elementFromPoint(clientX, clientY);\n          if (isInput(elementBehindCursor)) {\n            return;\n          }\n        }\n\n        var grabbed = shared.grabbed; // call to end() unsets shared.grabbed\n        eventualMovements(true); // remove mousemove listener\n        movements();\n        end();\n        start(grabbed);\n\n        // automaticly detect direction of elements if not set in options\n        if (!o.direction && getParent(shared.sourceItem)) {\n          var parent = shared.sourceItem.parentNode,\n            parentHeight = parent.offsetHeight,\n            parentWidth = parent.offsetWidth,\n            childHeight = shared.sourceItem.clientHeight,\n            childWidth = shared.sourceItem.clientWidth;\n          o.direction = parentHeight / childHeight < parentWidth / childWidth ? 'horizontal' : 'vertical';\n        }\n\n        // get initial coordinates, used to render shared.mirror for first time\n        var offset = getOffset(shared.sourceItem);\n        shared.offsetX = getCoord('pageX', e) - offset.left;\n        shared.offsetY = getCoord('pageY', e) - offset.top;\n        shared.clientX = getCoord('clientX', e);\n        shared.clientY = getCoord('clientY', e);\n\n        // limiting area of shared.mirror movement, get initial coordinates\n        if (o.boundingBox) {\n          shared.offsetXr = getCoord('pageX', e) - offset.right;\n          shared.offsetYb = getCoord('pageY', e) - offset.bottom;\n        }\n\n        e.preventDefault();\n\n        addClass(shared.item, o.classes.transit);\n        renderMirrorImage();\n        // initial position\n        shared.mirror.style.left = shared.clientX - shared.offsetX + 'px';\n        shared.mirror.style.top = shared.clientY - shared.offsetY + 'px';\n\n        drag(e);\n      }\n\n\n      function canStart(item) {\n        if (drake.dragging && shared.mirror) {\n          return; // already dragging\n        }\n\n        var handle = item;\n\n        while (getParent(item) && !isContainer(getParent(item))) {\n          // break loop if user tries to drag item which is considered invalid handle\n          if (o.invalid(item, handle)) {\n            return;\n          }\n          item = getParent(item); // drag target should be immediate child of container\n          if (!item) {\n            return;\n          }\n        }\n\n        var source = getParent(item);\n        if (!source ||\n          o.invalid(item, handle) ||\n          !o.moves(item, source, handle, nextEl(item))) {\n          return;\n        }\n\n        return {\n          item: item,\n          source: source\n        };\n      }\n\n      function manualStart(item) {\n        var context = canStart(item);\n        if (context) {\n          start(context);\n        }\n      }\n\n      function start(context) {\n        shared.sourceItem = shared.item = context.item;\n        shared.source = context.source;\n        shared.initialSibling = shared.currentSibling = nextEl(context.item);\n\n        if (isCopy(context.item, context.source)) {\n          shared.item = context.item.cloneNode(true);\n          shared.copy = true;\n          if (o.scope) {\n            o.scope.$emit(o.eventNames.dragularcloned, shared.item, context.item);\n          }\n        } else {\n          shared.copy = false;\n        }\n\n        // prepare models operations\n        var containerIndex = initialContainers.indexOf(context.source);\n        shared.sourceModel = o.containersModel[containerIndex];\n        shared.initialIndex = domIndexOf(context.item, context.source);\n\n        drake.dragging = true;\n        if (o.scope) {\n          o.scope.$emit(o.eventNames.dragulardrag, shared.sourceItem, shared.source);\n        }\n\n        return true;\n      }\n\n      function invalidTarget() {\n        return false;\n      }\n\n      function end() {\n        if (!drake.dragging || !shared.item) {\n          return;\n        }\n        drop(shared.item, getParent(shared.item));\n      }\n\n      function ungrab() {\n        shared.grabbed = false;\n        eventualMovements('remove');\n        movements('remove');\n      }\n\n      function release(e) {\n        ungrab();\n        if (!drake.dragging) {\n          return;\n        }\n        e = e || window.event;\n\n        shared.clientX = getCoord('clientX', e);\n        shared.clientY = getCoord('clientY', e);\n\n        var elementBehindCursor = getElementBehindPoint(shared.mirror, shared.clientX, shared.clientY),\n          dropTarget = findDropTarget(elementBehindCursor, shared.clientX, shared.clientY);\n\n        if (dropTarget && ((shared.copy && o.copySortSource) || (!shared.copy || dropTarget !== shared.source))) {\n          // found valid target and (is not copy case or target is not initial container)\n          drop(shared.item, dropTarget);\n        } else if (o.removeOnSpill) {\n          remove();\n        } else {\n          cancel();\n        }\n\n        // after release there is no container hovered\n        shared.target = null;\n\n        if (shared.lastElementBehindCursor) {\n          fireEvent(shared.lastElementBehindCursor, shared.dragOverEvents.dragularrelease, elementBehindCursor);\n        }\n\n        if (o.scope) {\n          o.scope.$emit(o.eventNames.dragularrelease, shared.item, shared.source);\n        }\n      }\n\n      function drop(item, target) {\n        if (shared.copy && o.copySortSource && target === shared.source && getParent(item)) {\n          item.parentNode.removeChild(shared.sourceItem);\n        }\n\n        var dropIndex = domIndexOf(item, target);\n\n        if (shared.sourceModel && !isInitialPlacement(target)) {\n          var dropElm = item;\n          $rootScope.$applyAsync(function applyDrop() {\n            if (target === shared.source) {\n              shared.sourceModel.splice(dropIndex, 0, shared.sourceModel.splice(shared.initialIndex, 1)[0]);\n            } else {\n              shared.dropElmModel = shared.copy ? angular.copy(shared.sourceModel[shared.initialIndex]) : shared.sourceModel[shared.initialIndex];\n\n              if (!shared.isContainerModel) {\n                shared.targetModel = shared.targetCtx.m;\n              } else {\n                shared.targetModel = shared.isContainerModel;\n              }\n\n              target.removeChild(dropElm); // element must be removed for ngRepeat to apply correctly\n\n              if (!shared.copy) {\n                shared.sourceModel.splice(shared.initialIndex, 1);\n              }\n              shared.targetModel.splice(dropIndex, 0, shared.dropElmModel);\n            }\n\n            if (getParent(item)) {\n              item.parentNode.removeChild(item);\n            }\n\n            emitDropEvent();\n            cleanup();\n          });\n        } else {\n          emitDropEvent();\n          cleanup();\n        }\n\n        function emitDropEvent() {\n          if (o.scope) {\n            if (isInitialPlacement(target)) {\n              o.scope.$emit(o.eventNames.dragularcancel, item, shared.source, shared.sourceModel, shared.initialIndex);\n            } else {\n              o.scope.$emit(o.eventNames.dragulardrop, item, target, shared.source, shared.sourceModel, shared.initialIndex, shared.targetModel, dropIndex);\n            }\n          }\n        }\n      }\n\n      function remove() {\n        if (!drake.dragging) {\n          return;\n        }\n        var parent = getParent(shared.item);\n\n        if (parent) {\n          parent.removeChild(shared.item);\n        }\n\n        if (shared.sourceModel) {\n          $rootScope.$applyAsync(function removeModel() {\n            shared.sourceModel.splice(shared.initialIndex, 1);\n            cleanup();\n          });\n        }\n\n        if (o.scope) {\n          o.scope.$emit(shared.copy ? o.eventNames.dragularcancel : o.eventNames.dragularremove, shared.item, parent, shared.sourceModel, shared.initialIndex);\n        }\n        if (!shared.sourceModel) {\n          cleanup();\n        }\n      }\n\n      function cancel(revert) {\n        if (!drake.dragging) {\n          return;\n        }\n        var reverts = arguments.length > 0 ? revert : o.revertOnSpill,\n          parent = getParent(shared.item);\n\n        var initial = isInitialPlacement(parent);\n        if (!initial && !shared.copy && reverts) {\n          shared.source.insertBefore(shared.item, shared.initialSibling);\n        }\n        if (shared.sourceModel && !shared.copy && !reverts) {\n          drop(shared.item, parent);\n        } else if (o.scope) {\n          if (initial || reverts) {\n            o.scope.$emit(o.eventNames.dragularcancel, shared.item, shared.source);\n          }\n        }\n\n        if (!shared.sourceModel || shared.copy || reverts || initial) {\n          cleanup();\n        }\n      }\n\n      function cleanup() {\n        ungrab();\n        removeMirrorImage();\n\n        if (shared.item) {\n          rmClass(shared.item, o.classes.transit);\n        }\n\n        drake.dragging = false;\n\n        if (o.removeOnSpill === true) {\n          spillOut();\n        }\n\n        if (o.scope) {\n          if(shared.lastDropTarget){\n           o.scope.$emit(o.eventNames.dragularout, shared.item, shared.lastDropTarget, shared.source);\n          }\n          o.scope.$emit(o.eventNames.dragulardragend, shared.item);\n        }\n\n        shared.source = shared.item = shared.sourceItem = shared.initialSibling = shared.currentSibling = shared.sourceModel = null;\n        shared.initialIndex = shared.currentIndex = shared.lastDropTarget = shared.isContainerModel = shared.targetModel = null;\n        shared.dropElmModel = shared.targetCtx = shared.copy = shared.moveX = shared.moveY = null;\n      }\n\n      // is item currently placed in original container and original position?\n      function isInitialPlacement(target, s) {\n        var sibling = s || (shared.mirror ? shared.currentSibling : nextEl(shared.item));\n        return target === shared.source && sibling === shared.initialSibling;\n      }\n\n      // find valid drop container\n      function findDropTarget(elementBehindCursor, clientX, clientY) {\n        var target = elementBehindCursor;\n\n        while (target && !accepted()) {\n          target = getParent(target);\n        }\n        return target;\n\n        function accepted() {\n          var accepts = false;\n\n          if (isContainer(target)) { // is droppable?\n\n            var immediate = getImmediateChild(target, elementBehindCursor),\n              reference = getReference(target, immediate, clientX, clientY),\n              initial = isInitialPlacement(target, reference),\n              i = o.nameSpace.length;\n\n            while (i--) {\n              if (shared.containers[o.nameSpace[i]].indexOf(target) !== -1) {\n                shared.targetCtx = shared.containersCtx[o.nameSpace[i]][shared.containers[o.nameSpace[i]].indexOf(target)];\n                break;\n              }\n              if (!shared.targetCtx) {\n                shared.targetCtx = shared.containersCtx.dragularCommon[shared.containers.dragularCommon.indexOf(target)];\n              }\n            }\n\n            accepts = initial ||\n              (shared.targetCtx.o.accepts(shared.item, target, shared.source, reference, shared.sourceModel, shared.initialIndex) &&\n                o.canBeAccepted(shared.item, target, shared.source, reference, shared.sourceModel, shared.initialIndex));\n\n            if (shared.target !== target) { // used for scroll issue\n              shared.target = target;\n            }\n          }\n          return accepts;\n        }\n      }\n\n      function drag(e) {\n        if (!shared.mirror) {\n          return;\n        }\n        e = e || window.event;\n\n        // update coordinates\n        shared.clientX = getCoord('clientX', e);\n        shared.clientY = getCoord('clientY', e);\n\n        // count mirror coordiates\n        var x = shared.clientX - shared.offsetX,\n          y = shared.clientY - shared.offsetY,\n          pageX,\n          pageY,\n          offsetBox;\n\n        // fill extra properties if boundingBox is used\n        if (o.boundingBox) {\n          pageX = getCoord('pageX', e);\n          pageY = getCoord('pageY', e);\n          offsetBox = getOffset(o.boundingBox);\n        }\n\n        if (!o.lockY) {\n          if (!o.boundingBox || (pageX > offsetBox.left + shared.offsetX && pageX < offsetBox.right + shared.offsetXr)) {\n            shared.mirror.style.left = x + 'px';\n          } else if (o.boundingBox) { // check again in case user scrolled the view\n            if (pageX < offsetBox.left + shared.offsetX) {\n              shared.mirror.style.left = shared.clientX - (pageX - offsetBox.left) + 'px';\n            } else {\n              shared.mirror.style.left = shared.clientX - shared.mirrorWidth - (pageX - offsetBox.right) + 'px';\n            }\n          }\n        }\n        if (!o.lockX) {\n          if (!o.boundingBox || (pageY > offsetBox.top + shared.offsetY && pageY < offsetBox.bottom + shared.offsetYb)) {\n            shared.mirror.style.top = y + 'px';\n          } else if (o.boundingBox) { // check again in case user scrolled the view\n            if (pageY < offsetBox.top + shared.offsetY) {\n              shared.mirror.style.top = shared.clientY - (pageY - offsetBox.top) + 'px';\n            } else {\n              shared.mirror.style.top = shared.clientY - shared.mirrorHeight - (pageY - offsetBox.bottom) + 'px';\n            }\n          }\n        }\n\n        var elementBehindCursor = getElementBehindPoint(shared.mirror, shared.clientX, shared.clientY),\n          dropTarget = findDropTarget(elementBehindCursor, shared.clientX, shared.clientY),\n          changed = dropTarget !== shared.lastDropTarget;\n\n        if (elementBehindCursor !== shared.lastElementBehindCursor) {\n          fireEvent(elementBehindCursor, shared.dragOverEvents.dragularenter, !!dropTarget);\n          if (shared.lastElementBehindCursor) {\n            fireEvent(shared.lastElementBehindCursor, shared.dragOverEvents.dragularleave, elementBehindCursor);\n          }\n          shared.lastElementBehindCursor = elementBehindCursor;\n        }\n\n        if (changed) {\n          out();\n          shared.lastDropTarget = dropTarget;\n          over();\n        }\n\n        // do not copy in same container\n        if (dropTarget === shared.source && shared.copy && !o.copySortSource) {\n          if (getParent(shared.item)) {\n            shared.item.parentNode.removeChild(shared.item);\n          }\n          return;\n        }\n\n        var reference,\n          immediate = getImmediateChild(dropTarget, elementBehindCursor);\n\n        if (immediate !== null) {\n          reference = getReference(dropTarget, immediate, shared.clientX, shared.clientY);\n        } else if (o.revertOnSpill === true && !shared.copy) {\n          // the case that mirror is not over valid target and reverting is on and copy is off\n          reference = shared.initialSibling;\n          dropTarget = shared.source;\n        } else {\n          // the case that mirror is not over valid target and removing is on or copy is on\n          if (shared.copy && getParent(shared.item)) {\n            // remove item or copy of item\n            shared.item.parentNode.removeChild(shared.item);\n          }\n          return;\n        }\n        if (reference === null ||\n          reference !== shared.item &&\n          reference !== nextEl(shared.item) &&\n          reference !== shared.currentSibling) {\n          // moving item/copy to new container from previous one\n          shared.currentSibling = reference;\n\n          dropTarget.insertBefore(shared.item, reference); // if reference is null item is inserted at the end\n\n          if (o.scope) {\n            o.scope.$emit(o.eventNames.dragularshadow, shared.item, dropTarget);\n          }\n        }\n\n        function moved(type) {\n          if (o.scope) {\n            o.scope.$emit(o.eventNames['dragular' + type], shared.item, shared.lastDropTarget, shared.source);\n          }\n          if (o.removeOnSpill === true) {\n            type === 'over' ? spillOver() : spillOut();\n          }\n        }\n\n        function over() {\n          if (changed) {\n            moved('over');\n          }\n        }\n\n        function out() {\n          if (shared.lastDropTarget) {\n            moved('out');\n          }\n        }\n      }\n\n      function spillOver() {\n        rmClass(shared.item, o.classes.hide);\n      }\n\n      function spillOut() {\n        if (drake.dragging) {\n          addClass(shared.item, o.classes.hide);\n        }\n      }\n\n      function scrollContainer(e) {\n        if (shared.target) {\n          var before = shared.target.scrollTop;\n          shared.target.scrollTop += e.deltaY;\n          // block scroll of the document when container can be scrolled\n          if (before !== shared.target.scrollTop) {\n            e.stopPropagation();\n            e.preventDefault();\n          }\n        }\n      }\n\n      function renderMirrorImage() {\n        if (shared.mirror) {\n          return;\n        }\n        var rect = shared.sourceItem.getBoundingClientRect();\n        shared.mirror = shared.sourceItem.cloneNode(true);\n        shared.mirrorWidth = rect.width;\n        shared.mirrorHeight = rect.height;\n        shared.mirror.style.width = getRectWidth(rect) + 'px';\n        shared.mirror.style.height = getRectHeight(rect) + 'px';\n        rmClass(shared.mirror, o.classes.transit);\n        addClass(shared.mirror, o.classes.mirror);\n        o.mirrorContainer.appendChild(shared.mirror);\n        regEvent(docElm, 'on', 'mousemove', drag);\n        addClass(body, o.classes.unselectable);\n        regEvent(shared.mirror, 'on', 'wheel', scrollContainer);\n        if (o.scope) {\n          o.scope.$emit(o.eventNames.dragularcloned, shared.mirror, shared.sourceItem);\n        }\n      }\n\n      function removeMirrorImage() {\n        if (shared.mirror) {\n          rmClass(body, o.classes.unselectable);\n          regEvent(docElm, 'off', 'mousemove', drag);\n          regEvent(shared.mirror, 'off', 'wheel', scrollContainer);\n          if(getParent(shared.mirror)){\n            shared.mirror.parentNode.removeChild(shared.mirror);\n          }\n          shared.mirror = null;\n        }\n      }\n\n      function getImmediateChild(dropTarget, target) {\n        var immediate = target;\n        while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {\n          immediate = getParent(immediate);\n        }\n        if (immediate === docElm) {\n          return null;\n        }\n        return immediate;\n      }\n\n      function getReference(dropTarget, target, x, y) {\n        var horizontal = o.direction === 'horizontal';\n        return target !== dropTarget ? inside() : outside();\n\n        function outside() { // slower, but able to figure out any position\n          var len = dropTarget.children.length,\n            i, el, rect;\n          for (i = 0; i < len; i++) {\n            el = dropTarget.children[i];\n            rect = el.getBoundingClientRect();\n            if (horizontal && rect.left > x) {\n              return el;\n            }\n            if (!horizontal && rect.top > y) {\n              return el;\n            }\n          }\n          return null;\n        }\n\n        function inside() { // faster, but only available if dropped inside a child element\n          var rect = target.getBoundingClientRect();\n          if (horizontal) {\n            return resolve(x > rect.left + getRectWidth(rect) / 2);\n          }\n          return resolve(y > rect.top + getRectHeight(rect) / 2);\n        }\n\n        function resolve(after) {\n          return after ? nextEl(target) : target;\n        }\n      }\n\n      function isCopy(item, container) {\n        return typeof o.copy === 'boolean' ? o.copy : o.copy(item, container);\n      }\n\n      function getScroll(scrollProp, offsetProp) {\n        if (typeof window[offsetProp] !== 'undefined') {\n          return window[offsetProp];\n        }\n        if (docElm.clientHeight) {\n          return docElm[scrollProp];\n        }\n        return body[scrollProp];\n      }\n\n      function getOffset(el) {\n        var rect = el.getBoundingClientRect(),\n          scrollTop = getScroll('scrollTop', 'pageYOffset'),\n          scrollLeft = getScroll('scrollLeft', 'pageXOffset');\n        return {\n          left: rect.left + scrollLeft,\n          right: rect.right + scrollLeft,\n          top: rect.top + scrollTop,\n          bottom: rect.bottom + scrollTop\n        };\n      }\n\n      function getElementBehindPoint(point, x, y) {\n        var p = point || {},\n          state = p.className,\n          el;\n        p.className += ' ' + o.classes.hide;\n        el = doc.elementFromPoint(x, y);\n        p.className = state;\n        return el;\n      }\n    }; // end of serviceFn\n\n  // clean common/shared objects\n  serviceFn.cleanEnviroment = function cleanEnviroment() {\n    shared.classesCache = {};\n    shared.containersCtx = {};\n    shared.containers = {};\n    shared.mirror = undefined;\n  };\n\n  serviceFn.shared = shared;\n\n  return serviceFn;\n\n  /****************************************************************************************************************************/\n  /****************************************************************************************************************************/\n  /****************************************************************************************************************************/\n\n  // HELPERS FUNCTIONS:\n\n  function regEvent(el, op, type, fn) {\n    var touch = {\n        mouseup: 'touchend',\n        mousedown: 'touchstart',\n        mousemove: 'touchmove'\n      },\n      $el = angular.element(el);\n\n    if (touch[type]) {\n      $el[op](touch[type], fn);\n    }\n    $el[op](type, fn);\n  }\n\n  function never() {\n    return false;\n  }\n\n  function always() {\n    return true;\n  }\n\n  function getRectWidth(rect) {\n    return rect.width || (rect.right - rect.left);\n  }\n\n  function getRectHeight(rect) {\n    return rect.height || (rect.bottom - rect.top);\n  }\n\n  function getEmptyObject() {\n    return {};\n  }\n\n  function nextEl(el) {\n    return el.nextElementSibling || manually();\n\n    function manually() {\n      var sibling = el;\n      do {\n        sibling = sibling.nextSibling;\n      } while (sibling && sibling.nodeType !== 1);\n      return sibling;\n    }\n  }\n\n  //Cannot use angular.isElement because we need to check plain dom element, no jQlite wrapped\n  function isElement(o) {\n    return (\n      typeof HTMLElement === 'object' ? o instanceof HTMLElement : //DOM2\n      o && typeof o === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string'\n    );\n  }\n\n  function lookupClass(className) {\n    var cached = shared.classesCache[className];\n    if (cached) {\n      cached.lastIndex = 0;\n    } else {\n      shared.classesCache[className] = cached = new RegExp('(?:^|\\\\s)' + className + '(?:\\\\s|$)', 'g');\n    }\n    return cached;\n  }\n\n  function addClass(el, className) {\n    var current = el.className;\n    if (!current.length) {\n      el.className = className;\n    } else if (!lookupClass(className).test(current)) {\n      el.className += ' ' + className;\n    }\n  }\n\n  function rmClass(el, className) {\n    el.className = el.className.replace(lookupClass(className), ' ').trim();\n  }\n\n  function getEventHost(e) {\n    // on touchend event, we have to use `e.changedTouches`\n    // see http://stackoverflow.com/questions/7192563/touchend-event-properties\n    // see https://github.com/bevacqua/dragula/issues/34\n    if (e.targetTouches && e.targetTouches.length) {\n      return e.targetTouches[0];\n    }\n    if (e.changedTouches && e.changedTouches.length) {\n      return e.changedTouches[0];\n    }\n    return e;\n  }\n\n  function getCoord(coord, e) {\n    var host = getEventHost(e);\n    var missMap = {\n      pageX: 'clientX', // IE8\n      pageY: 'clientY' // IE8\n    };\n    if (coord in missMap && !(coord in host) && missMap[coord] in host) {\n      coord = missMap[coord];\n    }\n\n    // Adding support for touch events, as they are not functional in the original\n    if (!host.type || host.type.indexOf('touch') < 0) {\n      return host[coord];\n    } else {\n      if (host.type.indexOf('end') === -1) {\n        // No clientX or clientY in a touch event\n        return host.originalEvent.touches[0][coord.replace('client', 'page')];\n      }\n      // Nothing should happen for touchend\n      return false;\n    }\n  }\n\n  function whichMouseButton (e) {\n    if (e.touches !== void 0) { return e.touches.length; }\n    if (e.buttons !== undefined) { return e.buttons; }\n    if (e.which !== undefined) { return e.which; }\n    var button = e.button;\n    if (button !== undefined) { // see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575\n      return button & 1 ? 1 : button & 2 ? 3 : (button & 4 ? 2 : 0);\n    }\n  }\n\n  function getParent (el) {\n    return el.parentNode === document ? null : el.parentNode;\n  }\n\n  function isInput (el) {\n    return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || isEditable(el);\n  }\n\n  function isEditable (el) {\n    if (!el) { return false; } // no parents were editable\n    if (el.contentEditable === 'false') { return false; } // stop the lookup\n    if (el.contentEditable === 'true') { return true; } // found a contentEditable element in the chain\n    return isEditable(getParent(el)); // contentEditable is set to 'inherit'\n  }\n\n  function domIndexOf(child, parent) {\n    return Array.prototype.indexOf.call(angular.element(parent).children(), child);\n  }\n\n  function fireEvent(target, e, extra) {\n    if (!target) {\n      return;\n    }\n    shared.extra = extra;\n    if (target.dispatchEvent) {\n      target.dispatchEvent(e);\n    } else {\n      target.fireEvent('on' + e.eventType, e);\n    }\n  }\n\n}]);\n\n},{\"./dragularModule\":2}]},{},[2]);\n"],"sourceRoot":"/source/"}