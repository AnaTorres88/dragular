{"version":3,"sources":["dragular.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","dragularModule","directive","dragularService","restrict","link","$scope","iElm","iAttrs","tryJson","json","JSON","parse","options","$eval","dragular","dragularModel","angular","extend","containersModel","./dragularModule",2,"dragularDirective","./dragularDirective.js","./dragularService.js",3,"factory","$rootScope","serviceFn","arg0","arg1","processServiceArguments","arguments","Array","isArray","isElement","initialContainers","document","querySelectorAll","extendDefaultOptions","classes","defaultClasses","eventNames","defaultEventNames","processOptionsObject","boundingBox","containers","makeArray","nameSpace","forEach","shared","containersCtx","len","shLen","m","registerEvents","remove","op","regEvent","docElm","release","container","grab","name","eventName","dragOverEvents","doc","createEvent","initEvent","createEventObject","eventType","window","event","moveX","clientX","moveY","clientY","whichMouseButton","metaKey","ctrlKey","context","canStart","target","item","grabbed","eventualMovements","type","isInput","focus","preventDefault","ungrab","drake","dragging","getCoord","elementBehindCursor","getElementBehindPoint","mirror","dropTarget","findDropTarget","copy","copySortSource","source","drop","removeOnSpill","cancel","lastElementBehindCursor","fireEvent","dragularrelease","scope","$emit","isContainer","el","indexOf","isContainerModel","removeContainers","all","$applyAsync","changes","index","splice","startBecauseMouseMoved","movements","preventGrabbed","destroy","ignoreInputTextSelection","elementFromPoint","end","start","direction","getParent","sourceItem","parent","parentNode","parentHeight","offsetHeight","parentWidth","offsetWidth","childHeight","clientHeight","childWidth","clientWidth","offset","getOffset","offsetX","left","offsetY","top","offsetXr","right","offsetYb","bottom","addClass","transit","renderMirrorImage","style","drag","handle","invalid","moves","nextEl","manualStart","initialSibling","currentSibling","isCopy","cloneNode","dragularcloned","containerIndex","sourceModel","initialIndex","domIndexOf","dragulardrag","invalidTarget","emitDropEvent","isInitialPlacement","dragularcancel","dragulardrop","targetModel","dropIndex","removeChild","dropElm","dropElmModel","targetCtx","cleanup","dragularremove","revert","reverts","revertOnSpill","initial","insertBefore","removeMirrorImage","rmClass","spillOut","lastDropTarget","dragularout","dragulardragend","currentIndex","sibling","accepted","accepts","immediate","getImmediateChild","reference","getReference","dragularCommon","canBeAccepted","moved","spillOver","over","changed","out","pageX","pageY","offsetBox","x","y","lockY","mirrorWidth","lockX","mirrorHeight","dragularenter","dragularleave","dragularshadow","hide","scrollContainer","before","scrollTop","deltaY","stopPropagation","rect","getBoundingClientRect","width","height","getRectWidth","getRectHeight","mirrorContainer","appendChild","body","unselectable","outside","children","horizontal","inside","resolve","after","getScroll","scrollProp","offsetProp","scrollLeft","point","p","state","className","documentElement","dragularover","always","never","getEmptyObject","fn","touch","mouseup","mousedown","mousemove","$el","element","startIndex","prototype","slice","touches","undefined","buttons","which","button","manually","nextSibling","nodeType","nextElementSibling","HTMLElement","nodeName","lookupClass","cached","classesCache","lastIndex","RegExp","current","test","replace","trim","getEventHost","targetTouches","changedTouches","coord","host","missMap","originalEvent","tagName","isEditable","contentEditable","child","extra","dispatchEvent","service","cleanEnviroment"],"mappings":"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","file":"dragular.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/* global angular */\n'use strict';\n\n/**\n * dragular Directive by Luckylooke https://github.com/luckylooke/dragular\n * Angular version of dragula https://github.com/bevacqua/dragula\n */\n var dragularModule = require('./dragularModule');\n\ndragularModule.directive('dragular', [\"dragularService\", function(dragularService) {\n  return {\n    restrict: 'A',\n    link: function($scope, iElm, iAttrs) {\n\n      var options = $scope.$eval(iAttrs.dragular) || tryJson(iAttrs.dragular) || {};\n\n      function tryJson(json) {\n        try { // I dont like try catch solutions but I havent find sattisfying way of chcecking json validity.\n          return JSON.parse(json);\n        } catch (e) {\n          return undefined;\n        }\n      }\n\n      if(iAttrs.dragularModel){\n        options = angular.extend({containersModel: $scope.$eval(iAttrs.dragularModel)}, options);\n      }else if(options && options.containersModel && typeof options.containersModel === 'string'){\n        options.containersModel = $scope.$eval(options.containersModel);\n      }\n\n      dragularService(iElm[0], options);\n    }\n  };\n}]);\n\n},{\"./dragularModule\":2}],2:[function(require,module,exports){\n/* global angular */\n'use strict';\n\n\n\n/**\n * Dragular 3.3.1 by Luckylooke https://github.com/luckylooke/dragular\n * Angular version of dragula https://github.com/bevacqua/dragula\n */\nmodule.exports = angular.module('dragularModule', []);\n\n({\"dragularDirective\":require(\"./dragularDirective.js\"),\"dragularService\":require(\"./dragularService.js\")});\n\n},{\"./dragularDirective.js\":1,\"./dragularService.js\":3}],3:[function(require,module,exports){\n/* global angular */\n'use strict';\n\n/**\n * dragular Service by Luckylooke https://github.com/luckylooke/dragular\n * Angular version of dragula https://github.com/bevacqua/dragula\n */\n\nvar dragularModule = require('./dragularModule');\n\ndragularModule.factory('dragularService', [\"$rootScope\", function dragularServiceFunction($rootScope) {\n\n  var shared = {\n      classesCache: {}, // classes lookup cache\n      containersCtx: {}, // containers model\n      containers: {}, // containers managed by the drake\n      mirror: null, // mirror image\n      source: null, // source container\n      item: null, // item being dragged\n      copy: null, // isCopy flag\n      sourceItem: null, // item originaly dragged if copy is enabled\n      sourceModel: null, // source container model\n      target: null, // droppable container under drag item\n      targetCtx: null, // target container context\n      targetModel: null, // target container model\n      lastDropTarget: null, // last container item was over\n      offsetX: null, // reference x\n      offsetY: null, // reference y\n      moveX: null, // reference move x\n      moveY: null, // reference move y\n      offsetXr: null, // reference x right for boundingBox feature\n      offsetYb: null, // reference y bottom for boundingBox feature\n      clientX: null, // cache client x, init at grab, update at drag\n      clientY: null, // cache client y, init at grab, update at drag\n      mirrorWidth: null, // mirror width for boundingBox feature\n      mirrorHeight: null, // mirror height for boundingBox feature\n      initialSibling: null, // reference sibling when grabbed\n      currentSibling: null, // reference sibling now\n      initialIndex: null, // reference model index when grabbed\n      currentIndex: null, // reference model index now\n      isContainerModel: null, // if o.isContainer is used, model can be provided as well, here it is kept\n      dragOverEvents: {}, // drag over events fired on element behind cursor\n      lastElementBehindCursor: null, // last element behind cursor\n      grabbed: null // holds mousedown context until first mousemove\n    },\n  // function returned by dragulaService\n    service = serviceFn;\n\n  // clean common/shared objects\n  service.cleanEnviroment = function cleanEnviroment() {\n    shared.classesCache = {};\n    shared.containersCtx = {};\n    shared.containers = {};\n    shared.mirror = undefined;\n  };\n\n  service.shared = shared;\n\n  return service;\n    \n  // service definition\n  function serviceFn(arg0, arg1) {\n    var initialContainers = arg0 || [],\n      options = arg1 || {},\n      // abbreviations\n      doc = document,\n      body = doc.body,\n      docElm = doc.documentElement,\n      // defaults\n      defaultClasses = {\n        mirror: 'gu-mirror',\n        hide: 'gu-hide',\n        unselectable: 'gu-unselectable',\n        transit: 'gu-transit'\n      },\n      defaultEventNames = {\n        // drag-over DOM events\n        dragularenter: 'dragularenter',\n        dragularleave: 'dragularleave',\n        dragularrelease: 'dragularrelease',\n        // $scope events\n        dragularcloned: 'dragularcloned',\n        dragulardrag: 'dragulardrag',\n        dragularcancel: 'dragularcancel',\n        dragulardrop: 'dragulardrop',\n        dragularremove: 'dragularremove',\n        dragulardragend: 'dragulardragend',\n        dragularshadow: 'dragularshadow',\n        dragularover: 'dragularover',\n        dragularout: 'dragularout'\n      },\n      o = { // options with defaults\n        // classes used by dragular\n        classes: defaultClasses,\n        // event names used by dragular\n        eventNames: defaultEventNames,\n        // initial containers provided via options object (are provided via parameter by default)\n        containers: false,\n        // can drag start?\n        moves: always,\n        // can target accept dragged item? (target context used)\n        accepts: always,\n        // can be dragged item accepted by target? (source context used)\n        canBeAccepted: always,\n        // potential target can be forced to be container by custom logic\n        isContainer: never,\n        // dragged item will be copy of source? flag or function\n        copy: false,\n        // target (in)validity function\n        invalid: invalidTarget,\n        // item returns to original place\n        revertOnSpill: false,\n        // item will be removed if not placed into valid target\n        removeOnSpill: false,\n        // lock movement into x-axis\n        lockX: false,\n        // lock movement into y-axis\n        lockY: false,\n        // lock movement inside this element boundaries\n        boundingBox: false,\n        // if provided, model will be synced with DOM\n        containersModel: false,\n        // if isContainer function is provided, you can provide also respective model\n        isContainerModel: getEmptyObject,\n        // element for appending mirror\n        mirrorContainer: doc.body,\n        // text selection in inputs wont be considered as drag\n        ignoreInputTextSelection: false\n      };\n\n    processServiceArguments(); // both arguments (containers and options) are optional, this function handle this\n    extendDefaultOptions();\n    processOptionsObject();\n    registerEvents();\n\n    var drake = {\n      containers: shared.containers,\n      containersCtx: shared.containersCtx,\n      isContainer: isContainer,\n      start: manualStart,\n      end: end,\n      cancel: cancel,\n      remove: remove,\n      destroy: destroy,\n      dragging: false\n    };\n\n    return drake;\n\n    // Function definitions: ==============================================================================================================\n    // Initial functions: -----------------------------------------------------------------------------------------------------------------\n\n    function processServiceArguments(){\n      if (arguments.length === 1 && // if there is only one argument we need to distinguish if it is options object or container(s) reference\n          !Array.isArray(arg0) && // array of containers elements\n          !angular.isElement(arg0) && // one container element\n          !arg0[0] && // array-like object with containers elements\n          typeof arg0 !== 'string') { // selector\n        // then arg0 is options object\n        options = arg0 || {};\n        initialContainers = []; // containers are not provided on init\n      } else if (typeof arg0 === 'string') {\n        initialContainers = document.querySelectorAll(arg0);\n      }\n    }\n\n    function extendDefaultOptions(){\n      angular.extend(o, options);\n      if(options.classes){\n        o.classes = angular.extend({}, defaultClasses, options.classes);\n      }\n      if(options.eventNames){\n        o.eventNames = angular.extend({}, defaultEventNames, options.eventNames);\n      }\n    }\n\n    function processOptionsObject(){\n      // bounding box must be pure DOM element, not jQuery wrapper or something else..\n      if (!isElement(o.boundingBox)) {\n        o.boundingBox = false;\n      }\n\n      // initial containers provided via options are higher priority then by parameter\n      if(o.containers){\n        initialContainers = o.containers;\n      }\n      // sanitize initialContainers\n      initialContainers = makeArray(initialContainers);\n\n      // sanitize o.containersModel\n      if (Array.isArray(o.containersModel)) {\n        //                  |-------- is 2D array? -----------|\n        o.containersModel = Array.isArray(o.containersModel[0]) ? o.containersModel : [o.containersModel];\n      } else {\n        o.containersModel = [];\n      }\n\n      // feed containers groups and optionaly do same for models\n      if (!o.nameSpace) {\n        o.nameSpace = ['dragularCommon'];\n      }\n      if (!Array.isArray(o.nameSpace)) {\n        o.nameSpace = [o.nameSpace];\n      }\n      o.nameSpace.forEach(function eachNameSpace(nameSpace) {\n        if (!shared.containers[nameSpace]) {\n          shared.containers[nameSpace] = [];\n          shared.containersCtx[nameSpace] = [];\n        }\n        var len = initialContainers.length,\n          shLen = shared.containers[nameSpace].length;\n        for (var i = 0; i < len; i++) {\n          shared.containers[nameSpace][i + shLen] = initialContainers[i];\n          shared.containersCtx[nameSpace][i + shLen] = {\n            o: o,\n            m: o.containersModel[i] // can be undefined\n          };\n        }\n      });\n    }\n\n    function registerEvents(remove) {\n      var op = remove ? 'off' : 'on';\n      regEvent(docElm, op, 'mouseup', release);\n      // regEvent(docElm, op, 'mousemove', startBecauseMouseMoved);\n\n      initialContainers.forEach(function addMouseDown(container) {\n        regEvent(container, 'on', 'mousedown', grab);\n      });\n\n      if(!remove){ // create dragular DOM events\n        angular.forEach(['dragularenter', 'dragularleave', 'dragularrelease'], function prepareDragOverEvents(name) {\n          var eventName = o.eventNames[name];\n          if(!shared.dragOverEvents[eventName]){\n            if (doc.createEvent) {\n              shared.dragOverEvents[eventName] = doc.createEvent('HTMLEvents');\n              shared.dragOverEvents[eventName].initEvent(eventName, true, true);\n            } else {\n              shared.dragOverEvents[eventName] = doc.createEventObject();\n              shared.dragOverEvents[eventName].eventType = eventName;\n            }\n          }\n        });\n      }\n    }\n    \n    // Event handlers functions (end of initial functions): -----------------------------------------------------------------------------------------------------------------\n\n    function grab(e) {\n      e = e || window.event;\n      shared.moveX = e.clientX;\n      shared.moveY = e.clientY;\n\n      // filter some odd situations\n      if (whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey) {\n        return; // we only care about honest-to-god left clicks and touch events\n      }\n\n      var context = canStart(e.target);\n      if (!context || !context.item) {\n        return;\n      }\n\n      shared.grabbed = context;\n      eventualMovements();\n      if (e.type === 'mousedown') {\n        if (isInput(context.item)) { // see also: https://github.com/bevacqua/dragula/issues/208\n          context.item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176\n        } else {\n          e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\n        }\n      }\n    }\n\n    function release(e) {\n      ungrab();\n      if (!drake.dragging) {\n        return;\n      }\n      e = e || window.event;\n\n      shared.clientX = getCoord('clientX', e);\n      shared.clientY = getCoord('clientY', e);\n\n      var elementBehindCursor = getElementBehindPoint(shared.mirror, shared.clientX, shared.clientY),\n        dropTarget = findDropTarget(elementBehindCursor, shared.clientX, shared.clientY);\n\n      if (dropTarget && ((shared.copy && o.copySortSource) || (!shared.copy || dropTarget !== shared.source))) {\n        // found valid target and (is not copy case or target is not initial container)\n        drop(shared.item, dropTarget);\n      } else if (o.removeOnSpill) {\n        remove();\n      } else {\n        cancel();\n      }\n\n      // after release there is no container hovered\n      shared.target = null;\n\n      if (shared.lastElementBehindCursor) {\n        fireEvent(shared.lastElementBehindCursor, shared.dragOverEvents.dragularrelease, elementBehindCursor);\n      }\n\n      if (o.scope) {\n        o.scope.$emit(o.eventNames.dragularrelease, shared.item, shared.source);\n      }\n    }\n    \n    // Main logic functions (end of event handler functions): -----------------------------------------------------------------------------------------------------------------\n\n    function isContainer(el) {\n      if(!el){\n        return false;\n      }\n      var i = o.nameSpace.length;\n      while (i--) {\n        if (shared.containers[o.nameSpace[i]].indexOf(el) !== -1) {\n          return true;\n        }\n      }\n      if (o.isContainer(el)) {\n        shared.isContainerModel = o.isContainerModel(el);\n        return true;\n      } else {\n        shared.isContainerModel = null;\n      }\n      return false;\n    }\n    \n    // Helper functions (end of main logic functions): -----------------------------------------------------------------------------------------------------------------\n\n    // add or remove containers - deprecated\n    function removeContainers(all) {\n      $rootScope.$applyAsync(function applyDestroyed() {\n        var changes = Array.isArray(all) ? all : makeArray(all);\n        changes.forEach(function forEachContainer(container) {\n          angular.forEach(o.nameSpace, function forEachNs(nameSpace) {\n            var index;\n            index = shared.containers[nameSpace].indexOf(container);\n            shared.containers[nameSpace].splice(index, 1);\n            shared.containersCtx[nameSpace].splice(index, 1);\n          });\n        });\n      });\n    }\n\n    function eventualMovements(remove) {\n      var op = remove ? 'off' : 'on';\n      regEvent(docElm, op, 'mousemove', startBecauseMouseMoved);\n    }\n\n    function movements(remove) {\n      var op = remove ? 'off' : 'on';\n      regEvent(docElm, op, 'selectstart', preventGrabbed); // IE8\n      regEvent(docElm, op, 'click', preventGrabbed);\n      regEvent(docElm, op, 'touchmove', preventGrabbed); // fixes touch devices scrolling while drag\n    }\n\n    function destroy() {\n      registerEvents(true);\n      removeContainers(initialContainers);\n      release({});\n    }\n\n    function preventGrabbed(e) {\n      if (shared.grabbed) {\n        e.preventDefault();\n      }\n    }\n\n    function startBecauseMouseMoved(e) {\n      if (!shared.grabbed || drake.dragging) {\n        return;\n      }\n      if (whichMouseButton(e) === 0) {\n        release({});\n        return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope\n      }\n      // truthy check fixes #239, equality fixes #207\n      if (e.clientX && e.clientX === shared.moveX && e.clientY && e.clientY === shared.moveY) {\n        return;\n      }\n      if (o.ignoreInputTextSelection) {\n        var clientX = getCoord('clientX', e),\n          clientY = getCoord('clientY', e),\n          elementBehindCursor = doc.elementFromPoint(clientX, clientY);\n        if (isInput(elementBehindCursor)) {\n          return;\n        }\n      }\n\n      var grabbed = shared.grabbed; // call to end() unsets shared.grabbed\n      eventualMovements(true); // remove mousemove listener\n      movements();\n      end();\n      start(grabbed);\n\n      // automaticly detect direction of elements if not set in options\n      if (!o.direction && getParent(shared.sourceItem)) {\n        var parent = shared.sourceItem.parentNode,\n          parentHeight = parent.offsetHeight,\n          parentWidth = parent.offsetWidth,\n          childHeight = shared.sourceItem.clientHeight,\n          childWidth = shared.sourceItem.clientWidth;\n        o.direction = parentHeight / childHeight < parentWidth / childWidth ? 'horizontal' : 'vertical';\n      }\n\n      // get initial coordinates, used to render shared.mirror for first time\n      var offset = getOffset(shared.sourceItem);\n      shared.offsetX = getCoord('pageX', e) - offset.left;\n      shared.offsetY = getCoord('pageY', e) - offset.top;\n      shared.clientX = getCoord('clientX', e);\n      shared.clientY = getCoord('clientY', e);\n\n      // limiting area of shared.mirror movement, get initial coordinates\n      if (o.boundingBox) {\n        shared.offsetXr = getCoord('pageX', e) - offset.right;\n        shared.offsetYb = getCoord('pageY', e) - offset.bottom;\n      }\n\n      e.preventDefault();\n\n      addClass(shared.item, o.classes.transit);\n      renderMirrorImage();\n      // initial position\n      shared.mirror.style.left = shared.clientX - shared.offsetX + 'px';\n      shared.mirror.style.top = shared.clientY - shared.offsetY + 'px';\n\n      drag(e);\n    }\n\n\n    function canStart(item) {\n      if (drake.dragging && shared.mirror) {\n        return; // already dragging\n      }\n\n      var handle = item;\n\n      while (getParent(item) && !isContainer(getParent(item))) {\n        // break loop if user tries to drag item which is considered invalid handle\n        if (o.invalid(item, handle)) {\n          return;\n        }\n        item = getParent(item); // drag target should be immediate child of container\n        if (!item) {\n          return;\n        }\n      }\n\n      var source = getParent(item);\n      if (!source ||\n        o.invalid(item, handle) ||\n        !o.moves(item, source, handle, nextEl(item))) {\n        return;\n      }\n\n      return {\n        item: item,\n        source: source\n      };\n    }\n\n    function manualStart(item) {\n      var context = canStart(item);\n      if (context) {\n        start(context);\n      }\n    }\n\n    function start(context) {\n      shared.sourceItem = shared.item = context.item;\n      shared.source = context.source;\n      shared.initialSibling = shared.currentSibling = nextEl(context.item);\n\n      if (isCopy(context.item, context.source)) {\n        shared.item = context.item.cloneNode(true);\n        shared.copy = true;\n        if (o.scope) {\n          o.scope.$emit(o.eventNames.dragularcloned, shared.item, context.item);\n        }\n      } else {\n        shared.copy = false;\n      }\n\n      // prepare models operations\n      var containerIndex = initialContainers.indexOf(context.source);\n      shared.sourceModel = o.containersModel[containerIndex];\n      shared.initialIndex = domIndexOf(context.item, context.source);\n\n      drake.dragging = true;\n      if (o.scope) {\n        o.scope.$emit(o.eventNames.dragulardrag, shared.sourceItem, shared.source);\n      }\n\n      return true;\n    }\n\n    function invalidTarget() {\n      return false;\n    }\n\n    function end() {\n      if (!drake.dragging || !shared.item) {\n        return;\n      }\n      drop(shared.item, getParent(shared.item));\n    }\n\n    function ungrab() {\n      shared.grabbed = false;\n      eventualMovements('remove');\n      movements('remove');\n    }\n\n    function drop(item, target) {\n      if (shared.copy && o.copySortSource && target === shared.source && getParent(item)) {\n        item.parentNode.removeChild(shared.sourceItem);\n      }\n\n      var dropIndex = domIndexOf(item, target);\n\n      if (shared.sourceModel && !isInitialPlacement(target)) {\n        var dropElm = item;\n        $rootScope.$applyAsync(function applyDrop() {\n          if (target === shared.source) {\n            shared.sourceModel.splice(dropIndex, 0, shared.sourceModel.splice(shared.initialIndex, 1)[0]);\n          } else {\n            shared.dropElmModel = shared.copy ? angular.copy(shared.sourceModel[shared.initialIndex]) : shared.sourceModel[shared.initialIndex];\n\n            if (!shared.isContainerModel) {\n              shared.targetModel = shared.targetCtx.m;\n            } else {\n              shared.targetModel = shared.isContainerModel;\n            }\n\n            target.removeChild(dropElm); // element must be removed for ngRepeat to apply correctly\n\n            if (!shared.copy) {\n              shared.sourceModel.splice(shared.initialIndex, 1);\n            }\n            shared.targetModel.splice(dropIndex, 0, shared.dropElmModel);\n          }\n\n          if (getParent(item)) {\n            item.parentNode.removeChild(item);\n          }\n\n          emitDropEvent();\n          cleanup();\n        });\n      } else {\n        emitDropEvent();\n        cleanup();\n      }\n\n      function emitDropEvent() {\n        if (o.scope) {\n          if (isInitialPlacement(target)) {\n            o.scope.$emit(o.eventNames.dragularcancel, item, shared.source, shared.sourceModel, shared.initialIndex);\n          } else {\n            o.scope.$emit(o.eventNames.dragulardrop, item, target, shared.source, shared.sourceModel, shared.initialIndex, shared.targetModel, dropIndex);\n          }\n        }\n      }\n    }\n\n    function remove() {\n      if (!drake.dragging) {\n        return;\n      }\n      var parent = getParent(shared.item);\n\n      if (parent) {\n        parent.removeChild(shared.item);\n      }\n\n      if (shared.sourceModel) {\n        $rootScope.$applyAsync(function removeModel() {\n          shared.sourceModel.splice(shared.initialIndex, 1);\n          cleanup();\n        });\n      }\n\n      if (o.scope) {\n        o.scope.$emit(shared.copy ? o.eventNames.dragularcancel : o.eventNames.dragularremove, shared.item, parent, shared.sourceModel, shared.initialIndex);\n      }\n      if (!shared.sourceModel) {\n        cleanup();\n      }\n    }\n\n    function cancel(revert) {\n      if (!drake.dragging) {\n        return;\n      }\n      var reverts = arguments.length > 0 ? revert : o.revertOnSpill,\n        parent = getParent(shared.item);\n\n      var initial = isInitialPlacement(parent);\n      if (!initial && !shared.copy && reverts) {\n        shared.source.insertBefore(shared.item, shared.initialSibling);\n      }\n      if (shared.sourceModel && !shared.copy && !reverts) {\n        drop(shared.item, parent);\n      } else if (o.scope) {\n        if (initial || reverts) {\n          o.scope.$emit(o.eventNames.dragularcancel, shared.item, shared.source);\n        }\n      }\n\n      if (!shared.sourceModel || shared.copy || reverts || initial) {\n        cleanup();\n      }\n    }\n\n    function cleanup() {\n      ungrab();\n      removeMirrorImage();\n\n      if (shared.item) {\n        rmClass(shared.item, o.classes.transit);\n      }\n\n      drake.dragging = false;\n\n      if (o.removeOnSpill === true) {\n        spillOut();\n      }\n\n      if (o.scope) {\n        if(shared.lastDropTarget){\n         o.scope.$emit(o.eventNames.dragularout, shared.item, shared.lastDropTarget, shared.source);\n        }\n        o.scope.$emit(o.eventNames.dragulardragend, shared.item);\n      }\n\n      shared.source = shared.item = shared.sourceItem = shared.initialSibling = shared.currentSibling = shared.sourceModel = null;\n      shared.initialIndex = shared.currentIndex = shared.lastDropTarget = shared.isContainerModel = shared.targetModel = null;\n      shared.dropElmModel = shared.targetCtx = shared.copy = shared.moveX = shared.moveY = null;\n    }\n\n    // is item currently placed in original container and original position?\n    function isInitialPlacement(target, s) {\n      var sibling = s || (shared.mirror ? shared.currentSibling : nextEl(shared.item));\n      return target === shared.source && sibling === shared.initialSibling;\n    }\n\n    // find valid drop container\n    function findDropTarget(elementBehindCursor, clientX, clientY) {\n      var target = elementBehindCursor;\n\n      while (target && !accepted()) {\n        target = getParent(target);\n      }\n      return target;\n\n      function accepted() {\n        var accepts = false;\n\n        if (isContainer(target)) { // is droppable?\n\n          var immediate = getImmediateChild(target, elementBehindCursor),\n            reference = getReference(target, immediate, clientX, clientY),\n            initial = isInitialPlacement(target, reference),\n            i = o.nameSpace.length;\n\n          while (i--) {\n            if (shared.containers[o.nameSpace[i]].indexOf(target) !== -1) {\n              shared.targetCtx = shared.containersCtx[o.nameSpace[i]][shared.containers[o.nameSpace[i]].indexOf(target)];\n              break;\n            }\n            if (!shared.targetCtx) {\n              shared.targetCtx = shared.containersCtx.dragularCommon[shared.containers.dragularCommon.indexOf(target)];\n            }\n          }\n\n          accepts = initial ||\n            (shared.targetCtx.o.accepts(shared.item, target, shared.source, reference, shared.sourceModel, shared.initialIndex) &&\n              o.canBeAccepted(shared.item, target, shared.source, reference, shared.sourceModel, shared.initialIndex));\n\n          if (shared.target !== target) { // used for scroll issue\n            shared.target = target;\n          }\n        }\n        return accepts;\n      }\n    }\n\n    function drag(e) {\n      if (!shared.mirror) {\n        return;\n      }\n      e = e || window.event;\n\n      // update coordinates\n      shared.clientX = getCoord('clientX', e);\n      shared.clientY = getCoord('clientY', e);\n\n      // count mirror coordiates\n      var x = shared.clientX - shared.offsetX,\n        y = shared.clientY - shared.offsetY,\n        pageX,\n        pageY,\n        offsetBox;\n\n      // fill extra properties if boundingBox is used\n      if (o.boundingBox) {\n        pageX = getCoord('pageX', e);\n        pageY = getCoord('pageY', e);\n        offsetBox = getOffset(o.boundingBox);\n      }\n\n      if (!o.lockY) {\n        if (!o.boundingBox || (pageX > offsetBox.left + shared.offsetX && pageX < offsetBox.right + shared.offsetXr)) {\n          shared.mirror.style.left = x + 'px';\n        } else if (o.boundingBox) { // check again in case user scrolled the view\n          if (pageX < offsetBox.left + shared.offsetX) {\n            shared.mirror.style.left = shared.clientX - (pageX - offsetBox.left) + 'px';\n          } else {\n            shared.mirror.style.left = shared.clientX - shared.mirrorWidth - (pageX - offsetBox.right) + 'px';\n          }\n        }\n      }\n      if (!o.lockX) {\n        if (!o.boundingBox || (pageY > offsetBox.top + shared.offsetY && pageY < offsetBox.bottom + shared.offsetYb)) {\n          shared.mirror.style.top = y + 'px';\n        } else if (o.boundingBox) { // check again in case user scrolled the view\n          if (pageY < offsetBox.top + shared.offsetY) {\n            shared.mirror.style.top = shared.clientY - (pageY - offsetBox.top) + 'px';\n          } else {\n            shared.mirror.style.top = shared.clientY - shared.mirrorHeight - (pageY - offsetBox.bottom) + 'px';\n          }\n        }\n      }\n\n      var elementBehindCursor = getElementBehindPoint(shared.mirror, shared.clientX, shared.clientY),\n        dropTarget = findDropTarget(elementBehindCursor, shared.clientX, shared.clientY),\n        changed = dropTarget !== shared.lastDropTarget;\n\n      if (elementBehindCursor !== shared.lastElementBehindCursor) {\n        fireEvent(elementBehindCursor, shared.dragOverEvents.dragularenter, !!dropTarget);\n        if (shared.lastElementBehindCursor) {\n          fireEvent(shared.lastElementBehindCursor, shared.dragOverEvents.dragularleave, elementBehindCursor);\n        }\n        shared.lastElementBehindCursor = elementBehindCursor;\n      }\n\n      if (changed) {\n        out();\n        shared.lastDropTarget = dropTarget;\n        over();\n      }\n\n      // do not copy in same container\n      if (dropTarget === shared.source && shared.copy && !o.copySortSource) {\n        if (getParent(shared.item)) {\n          shared.item.parentNode.removeChild(shared.item);\n        }\n        return;\n      }\n\n      var reference,\n        immediate = getImmediateChild(dropTarget, elementBehindCursor);\n\n      if (immediate !== null) {\n        reference = getReference(dropTarget, immediate, shared.clientX, shared.clientY);\n      } else if (o.revertOnSpill === true && !shared.copy) {\n        // the case that mirror is not over valid target and reverting is on and copy is off\n        reference = shared.initialSibling;\n        dropTarget = shared.source;\n      } else {\n        // the case that mirror is not over valid target and removing is on or copy is on\n        if (shared.copy && getParent(shared.item)) {\n          // remove item or copy of item\n          shared.item.parentNode.removeChild(shared.item);\n        }\n        return;\n      }\n      if (reference === null ||\n        reference !== shared.item &&\n        reference !== nextEl(shared.item) &&\n        reference !== shared.currentSibling) {\n        // moving item/copy to new container from previous one\n        shared.currentSibling = reference;\n\n        dropTarget.insertBefore(shared.item, reference); // if reference is null item is inserted at the end\n\n        if (o.scope) {\n          o.scope.$emit(o.eventNames.dragularshadow, shared.item, dropTarget);\n        }\n      }\n\n      function moved(type) {\n        if (o.scope) {\n          o.scope.$emit(o.eventNames['dragular' + type], shared.item, shared.lastDropTarget, shared.source);\n        }\n        if (o.removeOnSpill === true) {\n          type === 'over' ? spillOver() : spillOut();\n        }\n      }\n\n      function over() {\n        if (changed) {\n          moved('over');\n        }\n      }\n\n      function out() {\n        if (shared.lastDropTarget) {\n          moved('out');\n        }\n      }\n    }\n\n    function spillOver() {\n      rmClass(shared.item, o.classes.hide);\n    }\n\n    function spillOut() {\n      if (drake.dragging) {\n        addClass(shared.item, o.classes.hide);\n      }\n    }\n\n    function scrollContainer(e) {\n      if (shared.target) {\n        var before = shared.target.scrollTop;\n        shared.target.scrollTop += e.deltaY;\n        // block scroll of the document when container can be scrolled\n        if (before !== shared.target.scrollTop) {\n          e.stopPropagation();\n          e.preventDefault();\n        }\n      }\n    }\n\n    function renderMirrorImage() {\n      if (shared.mirror) {\n        return;\n      }\n      var rect = shared.sourceItem.getBoundingClientRect();\n      shared.mirror = shared.sourceItem.cloneNode(true);\n      shared.mirrorWidth = rect.width;\n      shared.mirrorHeight = rect.height;\n      shared.mirror.style.width = getRectWidth(rect) + 'px';\n      shared.mirror.style.height = getRectHeight(rect) + 'px';\n      rmClass(shared.mirror, o.classes.transit);\n      addClass(shared.mirror, o.classes.mirror);\n      o.mirrorContainer.appendChild(shared.mirror);\n      regEvent(docElm, 'on', 'mousemove', drag);\n      addClass(body, o.classes.unselectable);\n      regEvent(shared.mirror, 'on', 'wheel', scrollContainer);\n      if (o.scope) {\n        o.scope.$emit(o.eventNames.dragularcloned, shared.mirror, shared.sourceItem);\n      }\n    }\n\n    function removeMirrorImage() {\n      if (shared.mirror) {\n        rmClass(body, o.classes.unselectable);\n        regEvent(docElm, 'off', 'mousemove', drag);\n        regEvent(shared.mirror, 'off', 'wheel', scrollContainer);\n        if(getParent(shared.mirror)){\n          shared.mirror.parentNode.removeChild(shared.mirror);\n        }\n        shared.mirror = null;\n      }\n    }\n\n    function getImmediateChild(dropTarget, target) {\n      var immediate = target;\n      while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {\n        immediate = getParent(immediate);\n      }\n      if (immediate === docElm) {\n        return null;\n      }\n      return immediate;\n    }\n\n    function getReference(dropTarget, target, x, y) {\n      var horizontal = o.direction === 'horizontal';\n      return target !== dropTarget ? inside() : outside();\n\n      function outside() { // slower, but able to figure out any position\n        var len = dropTarget.children.length,\n          i, el, rect;\n        for (i = 0; i < len; i++) {\n          el = dropTarget.children[i];\n          rect = el.getBoundingClientRect();\n          if (horizontal && rect.left > x) {\n            return el;\n          }\n          if (!horizontal && rect.top > y) {\n            return el;\n          }\n        }\n        return null;\n      }\n\n      function inside() { // faster, but only available if dropped inside a child element\n        var rect = target.getBoundingClientRect();\n        if (horizontal) {\n          return resolve(x > rect.left + getRectWidth(rect) / 2);\n        }\n        return resolve(y > rect.top + getRectHeight(rect) / 2);\n      }\n\n      function resolve(after) {\n        return after ? nextEl(target) : target;\n      }\n    }\n\n    function isCopy(item, container) {\n      return typeof o.copy === 'boolean' ? o.copy : o.copy(item, container);\n    }\n\n    function getScroll(scrollProp, offsetProp) {\n      if (typeof window[offsetProp] !== 'undefined') {\n        return window[offsetProp];\n      }\n      if (docElm.clientHeight) {\n        return docElm[scrollProp];\n      }\n      return body[scrollProp];\n    }\n\n    function getOffset(el) {\n      var rect = el.getBoundingClientRect(),\n        scrollTop = getScroll('scrollTop', 'pageYOffset'),\n        scrollLeft = getScroll('scrollLeft', 'pageXOffset');\n      return {\n        left: rect.left + scrollLeft,\n        right: rect.right + scrollLeft,\n        top: rect.top + scrollTop,\n        bottom: rect.bottom + scrollTop\n      };\n    }\n\n    function getElementBehindPoint(point, x, y) {\n      var p = point || {},\n        state = p.className,\n        el;\n      p.className += ' ' + o.classes.hide;\n      el = doc.elementFromPoint(x, y);\n      p.className = state;\n      return el;\n    }\n  } // end of service\n\n  /****************************************************************************************************************************/\n  /****************************************************************************************************************************/\n  /****************************************************************************************************************************/\n\n  // HELPERS FUNCTIONS:\n\n  function regEvent(el, op, type, fn) {\n    var touch = {\n        mouseup: 'touchend',\n        mousedown: 'touchstart',\n        mousemove: 'touchmove'\n      },\n      $el = angular.element(el);\n\n    if (touch[type]) {\n      $el[op](touch[type], fn);\n    }\n    $el[op](type, fn);\n  }\n\n  function never() {\n    return false;\n  }\n\n  function always() {\n    return true;\n  }\n  \n  // make array from array-like objects or from single element (based on bevacqua/atoa)\n  function makeArray(all, startIndex) {\n    if (Array.isArray(all)) {\n      return all;\n    }\n    if (all.length) { // is array-like\n      return Array.prototype.slice.call(all, startIndex);\n    } else { // is one element\n      return [all];\n    }\n  }\n\n  function whichMouseButton (e) {\n    if (e.touches !== void 0) { return e.touches.length; }\n    if (e.buttons !== undefined) { return e.buttons; }\n    if (e.which !== undefined) { return e.which; }\n    var button = e.button;\n    if (button !== undefined) { // see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575\n      return button & 1 ? 1 : button & 2 ? 3 : (button & 4 ? 2 : 0);\n    }\n  }\n\n  function getRectWidth(rect) {\n    return rect.width || (rect.right - rect.left);\n  }\n\n  function getRectHeight(rect) {\n    return rect.height || (rect.bottom - rect.top);\n  }\n\n  function getEmptyObject() {\n    return {};\n  }\n\n  function nextEl(el) {\n    return el.nextElementSibling || manually();\n\n    function manually() {\n      var sibling = el;\n      do {\n        sibling = sibling.nextSibling;\n      } while (sibling && sibling.nodeType !== 1);\n      return sibling;\n    }\n  }\n\n  //Cannot use angular.isElement because we need to check plain dom element, no jQlite wrapped\n  function isElement(o) {\n    return (\n      typeof HTMLElement === 'object' ? o instanceof HTMLElement : //DOM2\n      o && typeof o === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string'\n    );\n  }\n\n  function lookupClass(className) {\n    var cached = shared.classesCache[className];\n    if (cached) {\n      cached.lastIndex = 0;\n    } else {\n      shared.classesCache[className] = cached = new RegExp('(?:^|\\\\s)' + className + '(?:\\\\s|$)', 'g');\n    }\n    return cached;\n  }\n\n  function addClass(el, className) {\n    var current = el.className;\n    if (!current.length) {\n      el.className = className;\n    } else if (!lookupClass(className).test(current)) {\n      el.className += ' ' + className;\n    }\n  }\n\n  function rmClass(el, className) {\n    el.className = el.className.replace(lookupClass(className), ' ').trim();\n  }\n\n  function getEventHost(e) {\n    // on touchend event, we have to use `e.changedTouches`\n    // see http://stackoverflow.com/questions/7192563/touchend-event-properties\n    // see https://github.com/bevacqua/dragula/issues/34\n    if (e.targetTouches && e.targetTouches.length) {\n      return e.targetTouches[0];\n    }\n    if (e.changedTouches && e.changedTouches.length) {\n      return e.changedTouches[0];\n    }\n    return e;\n  }\n\n  function getCoord(coord, e) {\n    var host = getEventHost(e);\n    var missMap = {\n      pageX: 'clientX', // IE8\n      pageY: 'clientY' // IE8\n    };\n    if (coord in missMap && !(coord in host) && missMap[coord] in host) {\n      coord = missMap[coord];\n    }\n\n    // Adding support for touch events, as they are not functional in the original\n    if (!host.type || host.type.indexOf('touch') < 0) {\n      return host[coord];\n    } else {\n      if (host.type.indexOf('end') === -1) {\n        // No clientX or clientY in a touch event\n        return host.originalEvent.touches[0][coord.replace('client', 'page')];\n      }\n      // Nothing should happen for touchend\n      return false;\n    }\n  }\n\n  function getParent (el) {\n    return el.parentNode === document ? null : el.parentNode;\n  }\n\n  function isInput (el) {\n    return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || isEditable(el);\n  }\n\n  function isEditable (el) {\n    if (!el) { return false; } // no parents were editable\n    if (el.contentEditable === 'false') { return false; } // stop the lookup\n    if (el.contentEditable === 'true') { return true; } // found a contentEditable element in the chain\n    return isEditable(getParent(el)); // contentEditable is set to 'inherit'\n  }\n\n  function domIndexOf(child, parent) {\n    return Array.prototype.indexOf.call(angular.element(parent).children(), child);\n  }\n\n  function fireEvent(target, e, extra) {\n    if (!target) {\n      return;\n    }\n    shared.extra = extra;\n    if (target.dispatchEvent) {\n      target.dispatchEvent(e);\n    } else {\n      target.fireEvent('on' + e.eventType, e);\n    }\n  }\n\n}]);\n\n},{\"./dragularModule\":2}]},{},[2]);\n"],"sourceRoot":"/source/"}